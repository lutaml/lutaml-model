require "spec_helper"
require "lutaml/model/schema"
require "lutaml/xsd"

RSpec.describe Lutaml::Model::Schema::XmlCompiler do
  describe ".to_models" do
    context "with valid xml schema, it should generate the models" do
      let(:valid_value_xml_example) do
        <<~VALID_XML_EXAMPLE
          <CT_MathTest>
            <MathTest val="1"/>
            <MathTest1 val="1"/>
          </CT_MathTest>
        VALID_XML_EXAMPLE
      end

      let(:invalid_value_xml_example) do
        <<~INVALID_XML_EXAMPLE
          <CT_MathTest>
            <MathTest val="0"/>
            <MathTest1 val="-3"/>
          </CT_MathTest>
        INVALID_XML_EXAMPLE
      end

      Dir.mktmpdir do |dir|
        it "creates the model files, requires them, and tests them with valid and invalid xml" do
          described_class.to_models(File.read("spec/fixtures/xml/test_schema.xsd"), output_dir: dir, create_files: true)
          expect(File).to exist("#{dir}/ct_math_test.rb")
          expect(File).to exist("#{dir}/st_integer255.rb")
          expect(File).to exist("#{dir}/long.rb")
          Dir.each_child(dir) { |child| require_relative File.expand_path("#{dir}/#{child}") }
          expect(defined?(CTMathTest)).to eq("constant")
          expect(CTMathTest.from_xml(valid_value_xml_example).to_xml).to be_equivalent_to(valid_value_xml_example)
          expect { CTMathTest.from_xml(invalid_value_xml_example) }.to raise_error(Lutaml::Model::Type::InvalidValueError)
        end
      end
    end

    context "when processing examples from classes/files generated by valid xml schema" do
      Dir.mktmpdir do |dir|
        before do
          described_class.to_models(
            File.read("spec/fixtures/xml/math_document_schema.xsd"),
            output_dir: dir,
            create_files: true,
          )
          require_relative "#{dir}/math_document"
        end

        let(:valid_example) do
          File.read("spec/fixtures/xml/valid_math_document.xml")
        end
        let(:invalid_example) do
          File.read("spec/fixtures/xml/invalid_math_document.xml")
        end

        it "does not raise error with valid example and creates files" do
          expect(defined?(MathDocument)).to eq("constant")
          parsed = MathDocument.from_xml(valid_example)
          expect(parsed.title).to eql("Example Title")
          expect(parsed.ipv4_address).to eql("192.168.1.1")
          expect(parsed.to_xml).to be_equivalent_to(valid_example)
        end

        it "raises InvalidValueError" do
          expect(defined?(MathDocument)).to eq("constant")
          expect { MathDocument.from_xml(invalid_example) }
            .to raise_error(Lutaml::Model::Type::InvalidValueError)
        end
      end
    end

    context "when processing example from lutaml-model#260" do
      Dir.mktmpdir do |dir|
        before do
          described_class.to_models(
            File.read("spec/fixtures/xml/address_example_260.xsd"),
            output_dir: dir,
            create_files: true,
          )
          require_relative "#{dir}/address"
        end

        let(:address) do
          <<~ADD
            <Address>
              Oxford Street
              <City>London</City>
              <ZIP>E1 6AN</ZIP>
            </Address>
          ADD
        end

        it "matches parsed xml with input" do
          expect(defined?(Address)).to eq("constant")
          expect(Address.from_xml(address).to_xml).to be_equivalent_to(address)
        end
      end
    end

    context "when classes are generated but files are not created" do
      let(:schema_classes_hash) do
        described_class.to_models(
          File.read("spec/fixtures/xml/user.xsd"),
        )
      end

      let(:expected_classes) do
        [
          "NonNegativeInteger",
          "PositiveInteger",
          "Base64Binary",
          "UnsignedLong",
          "UnsignedInt",
          "HexBinary",
          "Token",
          "Long",
          "Id",
          "User",
        ]
      end

      it "matches the expected class names of the schema" do
        expect(schema_classes_hash.keys).to eql(expected_classes)
      end
    end

    context "when classes are generated and loaded but files are not created" do
      before do
        described_class.to_models(
          File.read("spec/fixtures/xml/user.xsd"),
          load_classes: true,
        )
      end

      let(:expected_classes) do
        %w[
          NonNegativeInteger
          PositiveInteger
          Base64Binary
          UnsignedLong
          UnsignedInt
          HexBinary
          Token
          Long
          User
        ]
      end

      let(:xml) do
        <<~XML
          <User>
            <id>1112</id>
            <age>29</age>
            <token>u9dId901dp13f</token>
          </User>
        XML
      end

      it "matches the expected class names of the schema" do
        expected_classes.each do |klass|
          expect(be_const_defined(klass)).to be_truthy
        end
        expect(User.from_xml(xml).to_xml).to be_equivalent_to(xml)
      end
    end
  end

  describe "structure setup methods" do
    describe ".as_models" do
      let(:as_models) do
        described_class.send(:as_models, schema)
      end

      context "when the XML adapter is not set" do
        before do
          Lutaml::Model::Config.xml_adapter_type = :ox
        end

        after do
          Lutaml::Model::Config.xml_adapter_type = :nokogiri
        end

        let(:schema) do
          '<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"/>'
        end

        it "raises an error" do
          expect { as_models }.to raise_error(Lutaml::Model::Error)
        end
      end

      context "when the XML adapter is set and schema is given" do
        let(:schema) do
          '<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"/>'
        end

        let(:instance_variables) do
          %i[
            @elements
            @attributes
            @group_types
            @simple_types
            @complex_types
            @attribute_groups
          ]
        end

        it "initializes the instance variables with empty MappingHash" do
          as_models
          instance_variables.each do |variable|
            instance_variable = described_class.instance_variable_get(variable)

            expect(instance_variable)
              .to be_a(Lutaml::Model::MappingHash)
              .and be_empty
          end
        end

        it "parses the schema and populates the instance variables" do
          expect(described_class.send(:as_models, schema)).to be_nil
        end
      end
    end

    describe ".schema_to_models" do
      context "when given schema element is empty" do
        let(:schema) { [] }

        it "returns nil if schema array is empty" do
          expect(described_class.send(:schema_to_models, schema)).to be_nil
        end

        it "returns nil if schema array contains empty schema instance" do
          schema << Lutaml::Xsd::Schema.new
          expect(described_class.send(:schema_to_models, schema)).to be_nil
        end
      end

      context "when given schema contains all the elements" do
        before do
          variables.each_key do |key|
            described_class.instance_variable_set(
              :"@#{key}",
              to_mapping_hash({}),
            )
          end
        end

        after do
          variables.each_key do |key|
            described_class.instance_variable_set(:"@#{key}", nil)
          end
        end

        let(:schema) do
          Lutaml::Xsd.parse(<<~XSD)
            <xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema">
              <xsd:element name="test_element"/>
              <xsd:attribute name="test_attribute" type="xsd:string"/>
              <xsd:group name="test_group"/>
              <xsd:simpleType name="test_simple_type"/>
              <xsd:complexType name="test_complex_type" mixed="true"/>
              <xsd:attributeGroup name="test_attribute_group"/>
            </xsd:schema>
          XSD
        end

        let(:variables) do
          {
            elements: {
              "test_element" => {
                element_name: "test_element",
                type_name: nil,
              },
            },
            attributes: {
              "test_attribute" => {
                name: "test_attribute",
                base_class: "xsd:string",
              },
            },
            group_types: { "test_group" => {} },
            simple_types: { "test_simple_type" => {} },
            complex_types: { "test_complex_type" => { mixed: true } },
            attribute_groups: { "test_attribute_group" => {} },
          }
        end

        it "initializes the instance variables with empty MappingHash" do
          described_class.send(:schema_to_models, [schema])
          variables.each do |variable, expected_value|
            value = described_class.instance_variable_get(:"@#{variable}")

            expect(value)
              .to be_a(Lutaml::Model::MappingHash)
              .and eql(expected_value)
          end
        end
      end
    end

    describe ".setup_simple_type" do
      let(:setup_simple_type) do
        described_class.send(:setup_simple_type, simple_type)
      end

      context "when given simple_type contains restriction and union" do
        let(:simple_type) do
          Lutaml::Xsd::SimpleType.new.tap do |st|
            st.restriction = Lutaml::Xsd::RestrictionSimpleType.new(base: "test_base")
            st.union = Lutaml::Xsd::Union.new(member_types: "")
          end
        end

        let(:expected_output) { { base_class: "test_base", union: [] } }

        it "initializes the instance variables with empty MappingHash" do
          expect(setup_simple_type).to eql(expected_output)
        end
      end

      context "when simple_type contains nothing" do
        let(:simple_type) { Lutaml::Xsd::SimpleType.new }

        it "initializes the instance variables with empty MappingHash" do
          expect(setup_simple_type).to eql({})
        end
      end
    end

    describe ".restriction_content" do
      context "when given restriction contains max_length, min_length, min_inclusive, max_inclusive, length" do
        let(:restriction) do
          Lutaml::Xsd::RestrictionSimpleType.new.tap do |r|
            r.max_length = [Lutaml::Xsd::MaxLength.new(value: "10")]
            r.min_length = [Lutaml::Xsd::MinLength.new(value: "1")]
            r.min_inclusive = [Lutaml::Xsd::MinInclusive.new(value: "1")]
            r.max_inclusive = [Lutaml::Xsd::MaxInclusive.new(value: "10")]
            r.length = [Lutaml::Xsd::Length.new(value: "10")]
          end
        end

        let(:expected_output) do
          {
            max_length: 10,
            min_length: 1,
            min_inclusive: "1",
            max_inclusive: "10",
            length: [{ value: 10 }],
          }
        end

        it "initializes the instance variables with empty MappingHash" do
          described_class.send(:restriction_content, hash = {}, restriction)
          expect(hash).to eql(expected_output)
        end
      end

      context "when restriction contains nothing" do
        let(:restriction) { Lutaml::Xsd::RestrictionSimpleType.new }

        it "initializes the instance variables with empty MappingHash" do
          described_class.send(:restriction_content, hash = {}, restriction)
          expect(hash).to be_empty
        end
      end
    end

    describe ".restriction_length" do
      let(:restriction_length) do
        described_class.send(:restriction_length, lengths)
      end

      context "when given restriction contains max_length, min_length, min_inclusive, max_inclusive, length" do
        let(:lengths) do
          [
            Lutaml::Xsd::Length.new(value: "10", fixed: true),
            Lutaml::Xsd::Length.new(value: "1"),
            Lutaml::Xsd::Length.new(value: "1", fixed: true),
            Lutaml::Xsd::Length.new(value: "10"),
            Lutaml::Xsd::Length.new(value: "10", fixed: true),
          ]
        end

        let(:expected_content) do
          [
            { value: 10, fixed: true },
            { value: 1 },
            { value: 1, fixed: true },
            { value: 10 },
            { value: 10, fixed: true },
          ]
        end

        it "initializes the instance variables with empty MappingHash" do
          expect(restriction_length).to eql(expected_content)
        end
      end

      context "when restriction contains nothing" do
        let(:lengths) { [] }

        it "initializes the instance variables with empty MappingHash" do
          expect(restriction_length).to be_empty
        end
      end
    end

    describe ".setup_complex_type" do
      context "when given complex_type contains attribute, sequence, choice, complex_content, attribute_group, group, simple_content" do
        let(:complex_type) do
          Lutaml::Xsd::ComplexType.new.tap do |ct|
            ct.attribute = [Lutaml::Xsd::Attribute.new(type: "test_attribute", name: "test_attribute1")]
            ct.sequence = [Lutaml::Xsd::Sequence.new(name: "test_sequence")]
            ct.choice = [Lutaml::Xsd::Choice.new(name: "test_choice")]
            ct.complex_content = [Lutaml::Xsd::ComplexContent.new(name: "test_complex_content")]
            ct.attribute_group = [Lutaml::Xsd::AttributeGroup.new(name: "test_attribute_group")]
            ct.group = [Lutaml::Xsd::Group.new(name: "test_group")]
            ct.simple_content = [Lutaml::Xsd::SimpleContent.new(name: "test_simple_content")]
            ct.element_order = create_pattern_mapping([
                                                        ["Element", "attribute"],
                                                        ["Element", "sequence"],
                                                        ["Element", "choice"],
                                                        ["Element", "complex_content"],
                                                        ["Element", "attribute_group"],
                                                        ["Element", "group"],
                                                        ["Element", "simple_content"],
                                                      ])
          end
        end

        let(:expected_hash) do
          {
            attributes: [{ name: "test_attribute1", base_class: "test_attribute" }],
            sequence: {},
            choice: {},
            complex_content: {},
            attribute_groups: [{}],
            group: {},
            mixed: false,
            simple_content: nil,
          }
        end

        it "initializes the instance variables with empty MappingHash" do
          expect(described_class.send(:setup_complex_type, complex_type)).to eql(expected_hash)
        end
      end

      context "when restriction contains nothing" do
        let(:complex_type) do
          Lutaml::Xsd::ComplexType.new.tap do |ct|
            ct.element_order = []
          end
        end

        it "initializes the instance variables with empty MappingHash" do
          expect(described_class.send(:setup_complex_type, complex_type)).to eq({ mixed: false })
        end
      end
    end

    describe ".setup_simple_content" do
      let(:setup_simple_content) do
        described_class.send(:setup_simple_content, complex_type)
      end

      context "when given complex_type contains extension" do
        let(:complex_type) do
          Lutaml::Xsd::SimpleContent.new.tap do |ct|
            ct.extension = Lutaml::Xsd::ExtensionSimpleContent.new(base: "test_extension")
            ct.element_order = [
              Lutaml::Model::Xml::Element.new("Element", "extension"),
            ]
          end
        end

        let(:expected_hash) { { extension_base: "test_extension" } }

        it "initializes the instance variables with empty MappingHash" do
          expect(setup_simple_content).to eql(expected_hash)
        end
      end

      context "when complex_type contains restriction" do
        let(:complex_type) do
          Lutaml::Xsd::SimpleContent.new.tap do |ct|
            ct.restriction = Lutaml::Xsd::RestrictionSimpleContent.new(base: "test_restriction")
            ct.element_order = [
              Lutaml::Model::Xml::Element.new("Element", "restriction"),
            ]
          end
        end

        let(:expected_hash) { { base_class: "test_restriction" } }

        it "initializes the instance variables with empty MappingHash" do
          expect(setup_simple_content).to eql(expected_hash)
        end
      end
    end

    describe ".setup_sequence" do
      let(:setup_sequence) do
        described_class.send(:setup_sequence, sequence)
      end

      context "when given sequence contains sequence, element, choice, group" do
        let(:sequence) do
          Lutaml::Xsd::Sequence.new.tap do |ct|
            ct.sequence = [Lutaml::Xsd::Sequence.new(name: "test_sequence")]
            ct.element = [
              Lutaml::Xsd::Element.new(name: "test_element"),
              Lutaml::Xsd::Element.new(ref: "test_ref"),
            ]
            ct.choice = [Lutaml::Xsd::Choice.new(name: "test_choice")]
            ct.group = [
              Lutaml::Xsd::Group.new(name: "test_group"),
              Lutaml::Xsd::Group.new(ref: "test_ref"),
            ]
            ct.element_order = create_pattern_mapping([
                                                        ["Element", "sequence"],
                                                        ["Element", "group"],
                                                        ["Element", "element"],
                                                        ["Element", "choice"],
                                                        ["Element", "element"],
                                                        ["Element", "group"],
                                                      ])
          end
        end

        let(:expected_hash) do
          {
            sequences: [{}],
            elements: [
              { element_name: "test_element", type_name: nil },
              { ref_class: "test_ref" },
            ],
            choice: [{}],
            groups: [{}, { ref_class: "test_ref" }],
          }
        end

        it "initializes the instance variables with empty MappingHash" do
          expect(setup_sequence).to eql(expected_hash)
        end
      end

      context "when sequence contains nothing" do
        let(:sequence) do
          Lutaml::Xsd::Sequence.new.tap do |ct|
            ct.element_order = []
          end
        end

        it "initializes the instance variables with empty MappingHash" do
          expect(setup_sequence).to be_empty
        end
      end
    end

    describe ".setup_group_type" do
      let(:setup_group_type) do
        described_class.send(:setup_group_type, group)
      end

      context "when given group contains sequence, choice" do
        let(:group) do
          Lutaml::Xsd::Group.new.tap do |ct|
            ct.sequence = [Lutaml::Xsd::Sequence.new(name: "test_sequence")]
            ct.choice = [Lutaml::Xsd::Choice.new(name: "test_choice")]
            ct.element_order = create_pattern_mapping([
                                                        ["Element", "sequence"],
                                                        ["Element", "choice"],
                                                      ])
          end
        end

        let(:expected_hash) { { sequence: {}, choice: {} } }

        it "initializes the instance variables with empty MappingHash" do
          expect(setup_group_type).to eql(expected_hash)
        end
      end

      context "when sequence contains nothing" do
        let(:group) do
          Lutaml::Xsd::Group.new.tap do |ct|
            ct.element_order = []
          end
        end

        it "initializes the instance variables with empty MappingHash" do
          expect(setup_group_type).to be_empty
        end
      end
    end

    describe ".setup_choice" do
      let(:setup_choice) do
        described_class.send(:setup_choice, choice)
      end

      context "when given choice contains sequence, choice" do
        let(:choice) do
          Lutaml::Xsd::Choice.new.tap do |ct|
            ct.element = [Lutaml::Xsd::Element.new(name: "test_element")]
            ct.sequence = [Lutaml::Xsd::Sequence.new(name: "test_sequence")]
            ct.choice = [Lutaml::Xsd::Choice.new(name: "test_choice")]
            ct.group = [Lutaml::Xsd::Group.new(name: "test_group")]
            ct.element_order = create_pattern_mapping([
                                                        ["Element", "sequence"],
                                                        ["Element", "choice"],
                                                        ["Element", "group"],
                                                        ["Element", "element"],
                                                      ])
          end
        end

        let(:expected_hash) do
          {
            sequence: {},
            choice: {},
            group: {},
            "test_element" => {
              element_name: "test_element",
              type_name: nil,
            },
          }
        end

        it "initializes the instance variables with empty MappingHash" do
          expect(setup_choice).to eql(expected_hash)
        end
      end

      context "when choice contains nothing" do
        let(:choice) do
          Lutaml::Xsd::Choice.new.tap do |ct|
            ct.element_order = []
          end
        end

        it "initializes the instance variables with empty MappingHash" do
          expect(setup_choice).to be_empty
        end
      end
    end

    describe ".setup_union" do
      let(:setup_union) do
        described_class.send(:setup_union, union)
      end

      context "when given union contains member_types" do
        before do
          described_class.instance_variable_set(:@simple_types, simple_types)
        end

        after do
          described_class.instance_variable_set(:@simple_types, nil)
        end

        let(:simple_types) do
          {
            "test_member_type" => { name: "test_member_type" },
            "test_member_type1" => { name: "test_member_type1" },
          }
        end

        let(:union) do
          Lutaml::Xsd::Union.new.tap do |ct|
            ct.member_types = "test_member_type test_member_type1"
          end
        end

        let(:expected_output) do
          [
            { name: "test_member_type" },
            { name: "test_member_type1" },
          ]
        end

        it "returns the expected hash" do
          expect(setup_union).to eql(expected_output)
        end
      end

      context "when union contains nothing" do
        let(:union) { Lutaml::Xsd::Union.new }

        it "returns the empty hash" do
          expect(setup_union).to be_empty
        end
      end
    end

    describe ".setup_attribute" do
      let(:setup_attribute) do
        described_class.send(:setup_attribute, attribute)
      end

      context "when given attribute contains name and type" do
        let(:attribute) do
          Lutaml::Xsd::Attribute.new.tap do |attr|
            attr.name = "test_name"
            attr.type = "test_type"
          end
        end

        let(:expected_hash) { { name: "test_name", base_class: "test_type" } }

        it "returns the expected hash" do
          expect(setup_attribute).to eql(expected_hash)
        end
      end

      context "when given attribute contains ref" do
        let(:attribute) do
          Lutaml::Xsd::Attribute.new.tap do |attr|
            attr.ref = "test_ref"
          end
        end

        let(:expected_hash) { { ref_class: "test_ref" } }

        it "returns the expected hash" do
          expect(setup_attribute).to eql(expected_hash)
        end
      end

      context "when attribute contains nothing" do
        let(:attribute) { Lutaml::Xsd::Attribute.new }
        let(:expected_hash) { { name: nil, base_class: nil } }

        it "returns the empty hash" do
          expect(setup_attribute).to eql(expected_hash)
        end
      end
    end

    describe ".setup_attribute_groups" do
      let(:setup_attribute_groups) do
        described_class.send(:setup_attribute_groups, attribute_group)
      end

      context "when given attribute_group contains attribute and attribute_group" do
        let(:attribute_group) do
          Lutaml::Xsd::AttributeGroup.new.tap do |attr_group|
            attr_group.attribute = [Lutaml::Xsd::Attribute.new(name: "test_name", type: "test_type")]
            attr_group.attribute_group = [Lutaml::Xsd::AttributeGroup.new(name: "test_name", type: "test_type")]
            attr_group.element_order = create_pattern_mapping([
                                                                ["Element", "attribute"],
                                                                ["Element", "attribute_group"],
                                                              ])
          end
        end

        let(:expected_hash) do
          {
            attributes: [
              { name: "test_name", base_class: "test_type" },
            ],
            attribute_groups: [{}],
          }
        end

        it "returns the expected hash" do
          expect(setup_attribute_groups).to eql(expected_hash)
        end
      end

      context "when given attribute_group contains ref" do
        let(:attribute_group) do
          Lutaml::Xsd::AttributeGroup.new.tap do |attr_group|
            attr_group.ref = "test_ref"
          end
        end

        let(:expected_hash) { { ref_class: "test_ref" } }

        it "returns the expected hash" do
          expect(setup_attribute_groups).to eql(expected_hash)
        end
      end

      context "when attribute_group contains nothing" do
        let(:attribute_group) { Lutaml::Xsd::AttributeGroup.new }

        it "returns the empty hash" do
          expect(setup_attribute_groups).to be_empty
        end
      end
    end

    describe ".create_mapping_hash" do
      context "when given value is a string and hash_key is :class_name" do
        let(:value) { "test_value" }
        let(:expected_hash) { { class_name: "test_value" } }

        it "returns the expected hash" do
          expect(described_class.send(:create_mapping_hash, value, hash_key: :class_name)).to eql(expected_hash)
        end
      end

      context "when given value is a string and hash_key is :element_name" do
        let(:value) { "test_value" }
        let(:expected_hash) { { element_name: "test_value" } }

        it "returns the expected hash" do
          expect(described_class.send(:create_mapping_hash, value, hash_key: :element_name)).to eql(expected_hash)
        end
      end

      context "when given value is a array and hash_key is :ref_class" do
        let(:value) { ["test_value"] }
        let(:expected_hash) { { ref_class: ["test_value"] } }

        it "returns the expected hash" do
          expect(described_class.send(:create_mapping_hash, value, hash_key: :ref_class)).to eql(expected_hash)
        end
      end

      context "when given value is a string and hash_key is not given" do
        let(:value) { "test_value" }
        let(:expected_hash) { { class_name: "test_value" } }

        it "returns the expected hash" do
          expect(described_class.send(:create_mapping_hash, value)).to eql(expected_hash)
        end
      end
    end

    describe ".setup_element" do
      before do
        described_class.instance_variable_set(:@complex_types, complex_types)
      end

      after do
        described_class.instance_variable_set(:@complex_types, nil)
      end

      let(:setup_element) do
        described_class.send(:setup_element, element)
      end

      let(:complex_types) { { "test_complex_type" => {} } }

      context "when given element contains ref" do
        let(:element) do
          Lutaml::Xsd::Element.new.tap do |element|
            element.ref = "test_ref"
          end
        end

        let(:expected_hash) { { ref_class: "test_ref" } }

        it "returns the expected hash" do
          expect(setup_element).to eql(expected_hash)
        end
      end

      context "when given element contains ref with other attributes/elements" do
        let(:element) do
          Lutaml::Xsd::Element.new.tap do |element|
            element.ref = "test_ref"
            element.type = "test_type"
            element.name = "test_name"
            element.min_occurs = 0
            element.max_occurs = 1
            element.complex_type = Lutaml::Xsd::ComplexType.new(name: "test_complex_type")
            element.element_order = [Lutaml::Model::Xml::Element.new("Element", "complex_type")]
          end
        end

        let(:expected_hash) { { ref_class: "test_ref" } }

        it "returns the expected hash" do
          expect(setup_element).to eql(expected_hash)
        end
      end

      context "when given element contains type, name and min/max_occurs" do
        let(:element) do
          Lutaml::Xsd::Element.new.tap do |element|
            element.type = "test_type"
            element.name = "test_name"
            element.min_occurs = 0
            element.max_occurs = 1
          end
        end

        let(:expected_hash) do
          {
            type_name: "test_type",
            element_name: "test_name",
            arguments: { min_occurs: "0", max_occurs: "1" },
          }
        end

        it "returns the expected hash" do
          expect(setup_element).to eql(expected_hash)
        end
      end

      context "when given element contains name, type, and complex_type and no min/max_occurs" do
        let(:element) do
          Lutaml::Xsd::Element.new.tap do |element|
            element.type = "test_type"
            element.name = "test_name"
            element.complex_type = Lutaml::Xsd::ComplexType.new(name: "test_complex_type")
            element.element_order = [Lutaml::Model::Xml::Element.new("Element", "complex_type")]
          end
        end

        let(:expected_hash) do
          {
            type_name: "test_type",
            element_name: "test_name",
            complex_type: { mixed: false },
          }
        end

        it "returns the expected hash" do
          expect(setup_element).to eql(expected_hash)
        end
      end

      context "when given element contains nothing" do
        let(:element) { Lutaml::Xsd::Element.new }
        let(:expected_hash) { { type_name: nil, element_name: nil } }

        it "returns the expected hash" do
          expect(setup_element).to eql(expected_hash)
        end
      end
    end

    describe ".setup_restriction" do
      let(:setup_restriction) do
        described_class.send(:setup_restriction, restriction, {})
      end

      context "when given restriction contains base and pattern" do
        let(:restriction) do
          Lutaml::Xsd::RestrictionSimpleType.new.tap do |restriction|
            restriction.base = "test_base"
            restriction.pattern = [
              Lutaml::Xsd::Pattern.new(value: /test_pattern/),
              Lutaml::Xsd::Pattern.new(value: /test_pattern1/),
            ]
            restriction.enumeration = [
              Lutaml::Xsd::Enumeration.new(value: "test_value"),
              Lutaml::Xsd::Enumeration.new(value: "test_value1"),
            ]
          end
        end

        let(:expected_hash) do
          {
            base_class: "test_base",
            pattern: "((?-mix:test_pattern))|((?-mix:test_pattern1))",
            values: ["test_value", "test_value1"],
          }
        end

        it "returns the expected hash" do
          expect(setup_restriction).to eql(expected_hash)
        end
      end

      context "when given restriction contains nothing" do
        let(:restriction) { Lutaml::Xsd::RestrictionSimpleType.new }

        it "returns the expected hash" do
          expect(setup_restriction).to eql({ base_class: nil })
        end
      end
    end

    describe ".restriction_patterns" do
      let(:restriction_patterns) do
        described_class.send(:restriction_patterns, patterns, {})
      end

      context "when given patterns are not empty" do
        let(:patterns) do
          [
            Lutaml::Xsd::Pattern.new(value: /test_pattern/),
            Lutaml::Xsd::Pattern.new(value: /test_pattern1/),
          ]
        end

        let(:expected_hash) do
          { pattern: "((?-mix:test_pattern))|((?-mix:test_pattern1))" }
        end

        it "returns the expected hash" do
          expect(restriction_patterns).to eql(expected_hash)
        end
      end

      context "when given patterns are empty" do
        let(:patterns) { [] }

        it "returns the expected hash" do
          expect(restriction_patterns).to be_nil
        end
      end
    end

    describe ".setup_complex_content" do
      let(:setup_complex_content) do
        described_class.send(:setup_complex_content, complex_content)
      end

      context "when complex_content contains extension with mixed attribute" do
        let(:complex_content) do
          Lutaml::Xsd::ComplexContent.new.tap do |complex_content|
            complex_content.mixed = true
            complex_content.extension =
              Lutaml::Xsd::ExtensionComplexContent.new(base: "test_base")
          end
        end

        let(:expected_hash) do
          { mixed: true, extension: { extension_base: "test_base" } }
        end

        it "returns the expected hash" do
          expect(setup_complex_content).to eql(expected_hash)
        end
      end

      context "when complex_content contains restriction" do
        let(:complex_content) do
          Lutaml::Xsd::ComplexContent.new.tap do |complex_content|
            complex_content.restriction =
              Lutaml::Xsd::RestrictionComplexContent.new(base: "test_base")
          end
        end

        let(:expected_hash) { { base_class: "test_base" } }

        it "returns the expected hash" do
          expect(setup_complex_content).to eql(expected_hash)
        end
      end
    end

    describe ".setup_extension" do
      let(:setup_extension) do
        described_class.send(:setup_extension, extension)
      end

      context "when given extension contains attributes" do
        let(:extension) do
          Lutaml::Xsd::ExtensionComplexContent.new.tap do |extension|
            extension.base = "test_base"
            extension.attribute = [
              Lutaml::Xsd::Attribute.new(type: "ST_Attr1", name: "Attr1", default: "1"),
              Lutaml::Xsd::Attribute.new(type: "ST_Attr2", name: "Attr2", default: "2"),
            ]
            extension.sequence = Lutaml::Xsd::Sequence.new
            extension.choice = Lutaml::Xsd::Choice.new
            extension.element_order = create_pattern_mapping([
                                                               ["Element", "attribute"],
                                                               ["Element", "sequence"],
                                                               ["Element", "choice"],
                                                               ["Element", "attribute"],
                                                             ])
          end
        end

        let(:expected_hash) do
          {
            extension_base: "test_base",
            attributes: [{ base_class: "ST_Attr1", name: "Attr1", default: "1" }, { base_class: "ST_Attr2", name: "Attr2", default: "2" }],
            sequence: {},
            choice: {},
          }
        end

        it "returns the expected hash" do
          expect(setup_extension).to eql(expected_hash)
        end
      end

      context "when given extension contains nothing" do
        let(:extension) { Lutaml::Xsd::ExtensionComplexContent.new }

        it "returns the expected hash" do
          expect(setup_extension).to eql({ extension_base: nil })
        end
      end
    end

    describe ".element_arguments" do
      let(:element_arguments) do
        described_class.send(:element_arguments, element, {})
      end

      context "when given element contains min_occurs and max_occurs" do
        let(:element) do
          Lutaml::Xsd::Element.new.tap do |element|
            element.min_occurs = "0"
            element.max_occurs = "1"
          end
        end

        let(:expected_hash) { { min_occurs: "0", max_occurs: "1" } }

        it "returns the expected hash" do
          expect(element_arguments).to eql(expected_hash)
        end
      end

      context "when given element contains nothing" do
        let(:element) { Lutaml::Xsd::Element.new }

        it "returns the expected hash" do
          expect(element_arguments).to be_empty
        end
      end
    end

    describe ".resolved_element_order" do
      let(:resolved_element_order) do
        described_class.send(:resolved_element_order, element)
      end

      context "when given element contains element_order but no instance relevant elements/instances" do
        let(:element) do
          Lutaml::Xsd::Element.new.tap do |element|
            element.element_order = create_pattern_mapping([
                                                             ["Element", "annotation"],
                                                             ["Element", "simple_type"],
                                                             ["Element", "complex_type"],
                                                             ["Element", "key"],
                                                           ])
          end
        end

        it "raises an error when element_order contains elements that isn't an attribute of the instance" do
          element.element_order << Lutaml::Model::Xml::Element.new("Element", "test_element")
          expect { resolved_element_order }.to raise_error(NoMethodError)
        end

        it "returns the array with nil values" do
          expected_hash = [nil, nil, nil, nil]
          expect(resolved_element_order).to eql(expected_hash)
        end
      end

      context "when given element contains element_order but with relevant elements/instances" do
        let(:element) do
          Lutaml::Xsd::Element.new.tap do |element|
            element.annotation = Lutaml::Xsd::Annotation.new
            element.simple_type = Lutaml::Xsd::SimpleType.new
            element.complex_type = Lutaml::Xsd::ComplexType.new
            element.key = Lutaml::Xsd::Key.new
            element.element_order = create_pattern_mapping([
                                                             ["Element", "annotation"],
                                                             ["Element", "simple_type"],
                                                             ["Element", "complex_type"],
                                                             ["Element", "key"],
                                                           ])
          end
        end

        let(:expected_hash) do
          [
            element.annotation,
            element.simple_type,
            element.complex_type,
            element.key,
          ]
        end

        it "returns the expected hash" do
          expect(resolved_element_order).to eql(expected_hash)
        end
      end

      context "when given element contains empty element_order with elements/instances" do
        let(:element) do
          Lutaml::Xsd::Element.new.tap do |element|
            element.element_order = []
          end
        end

        it "returns the expected hash" do
          expect(resolved_element_order).to be_empty
        end
      end
    end
  end

  describe "structure to template content resolving methods" do
    describe ".resolve_parent_class" do
      let(:resolve_parent_class) do
        described_class.send(:resolve_parent_class, content)
      end

      context "when complex_content.extension is not present" do
        let(:content) { {} }

        it "returns Lutaml::Model::Serializable" do
          expect(resolve_parent_class).to eql("Lutaml::Model::Serializable")
        end
      end

      context "when complex_content.extension is present" do
        let(:content) do
          { complex_content: { extension: { extension_base: "ST_Parent" } } }
        end

        it "returns the extension_base value" do
          expect(resolve_parent_class).to eql("STParent")
        end
      end
    end

    describe ".resolve_attribute_class" do
      let(:resolve_attribute_class) do
        described_class.send(:resolve_attribute_class, base_class_hash)
      end

      described_class::DEFAULT_CLASSES.each do |standard_class|
        context "when #{standard_class.capitalize}" do
          let(:base_class_hash) do
            to_mapping_hash({ base_class: "xsd:#{standard_class}" })
          end

          it "returns :#{standard_class}" do
            expect(resolve_attribute_class).to eql(":#{standard_class}")
          end
        end
      end

      context "when attribute.base_class is not one of the standard classes" do
        let(:base_class_hash) do
          to_mapping_hash({ base_class: "test_st_attr1" })
        end

        it "returns the attribute_class value" do
          expect(resolve_attribute_class).to eql(":test_st_attr1")
        end
      end
    end

    describe ".resolve_element_class" do
      let(:resolve_element_class) do
        described_class.send(:resolve_element_class, type_name_hash)
      end

      described_class::DEFAULT_CLASSES.each do |standard_class|
        context "when #{standard_class.capitalize}" do
          let(:type_name_hash) do
            to_mapping_hash({ type_name: "xsd:#{standard_class}" })
          end

          it "returns :#{standard_class}" do
            expect(resolve_element_class).to eql(":#{standard_class}")
          end
        end
      end

      context "when element.type_name is not one of the standard classes" do
        let(:type_name_hash) do
          to_mapping_hash({ type_name: "test_st_element1" })
        end

        it "returns the element_class value" do
          expect(resolve_element_class).to eql(":test_st_element1")
        end
      end
    end

    describe ".resolve_occurs" do
      let(:resolve_occours) do
        described_class.send(:resolve_occurs, base_class_hash)
      end

      context "when max_occurs is unbounded" do
        let(:base_class_hash) do
          to_mapping_hash({ min_occurs: 0, max_occurs: "unbounded" })
        end

        it "returns the collection: true" do
          expect(resolve_occours).to eql(", collection: true")
        end
      end

      context "when max_occurs is 1" do
        let(:base_class_hash) do
          to_mapping_hash({ min_occurs: 0, max_occurs: 1 })
        end

        it "returns the collection: 0..1" do
          expect(resolve_occours).to eql(", collection: 0..1")
        end
      end

      context "when min_occurs/max_occurs are not present" do
        let(:base_class_hash) { {} }

        it "returns the collection: 0.." do
          expect(resolve_occours).to eql(", collection: true")
        end
      end
    end

    describe ".resolve_elements" do
      before do
        described_class.instance_variable_set(:@elements, elements)
      end

      after do
        described_class.instance_variable_set(:@elements, nil)
      end

      let(:resolve_elements) do
        described_class.send(:resolve_elements, content)
      end

      let(:elements) do
        to_mapping_hash(
          { "testRef" => to_mapping_hash({ element_name: "testElement" }) },
        )
      end

      context "when elements contain ref_class and base_class elements" do
        let(:content) do
          [
            to_mapping_hash({ ref_class: "testRef" }),
            to_mapping_hash({ element_name: "testElement1" }),
          ]
        end

        let(:expected_elements) do
          {
            "testElement" => { element_name: "testElement" },
            "testElement1" => { element_name: "testElement1" },
          }
        end

        it "returns the elements hash" do
          expect(resolve_elements).to eql(expected_elements)
        end
      end
    end

    describe ".resolve_content" do
      let(:content) do
        {
          sequence: [],
          choice: [],
          group: [],
        }
      end

      context "when content contain empty sequence, choice and group" do
        it "returns the elements hash" do
          expect(described_class.send(:resolve_content, content)).to be_empty
        end
      end
    end

    describe ".resolve_sequence" do
      let(:sequence) do
        {
          sequence: [],
          elements: [],
          groups: [],
          choice: [],
        }
      end

      context "when sequence contain empty elements and empty attributes" do
        it "returns the elements empty hash" do
          expect(described_class.send(:resolve_sequence, sequence)).to be_empty
        end
      end
    end

    describe ".resolve_choice" do
      let(:resolve_choice) do
        described_class.send(:resolve_choice, choice)
      end

      let(:choice) do
        {
          "string" => to_mapping_hash({ element_name: "testElement" }),
          sequence: [],
          element: [],
          group: [],
        }
      end

      context "when choice contain empty elements and other empty attributes" do
        it "returns the one element hash" do
          expect(resolve_choice)
            .to eql({ "string" => { element_name: "testElement" } })
        end
      end
    end

    describe ".resolve_group" do
      before do
        described_class.instance_variable_set(:@group_types, group_types)
      end

      after do
        described_class.instance_variable_set(:@group_types, nil)
      end

      let(:group_types) { { "testRef" => {} } }

      let(:group) do
        {
          ref_class: "testRef",
          sequence: [],
          choice: [],
          group: [],
        }
      end

      context "when group contain ref_class and other empty attributes" do
        it "returns the one element hash" do
          expect(described_class.send(:resolve_group, group)).to be_empty
        end
      end
    end

    describe ".resolve_complex_content" do
      let(:resolve_complex_content) do
        described_class.send(:resolve_complex_content, complex_content)
      end

      let(:complex_content) do
        {
          extension: {},
          restriction: {},
        }
      end

      context "when complex_content contain extension and restriction" do
        it "returns the one element hash" do
          expect(resolve_complex_content).to be_empty
        end
      end
    end

    describe ".resolve_extension" do
      let(:resolve_extension) do
        described_class.send(:resolve_extension, to_mapping_hash(extension))
      end

      let(:extension) do
        {
          attributes: [
            { base_class: "ST_Attr1", default: "1" },
            { base_class: "ST_Attr2", default: "2" },
          ],
          sequence: {},
          choice: {},
        }
      end

      context "when extension contain attributes, sequence and choice" do
        it "returns the one element hash" do
          expect(resolve_extension)
            .to eql({ attributes: extension[:attributes] })
        end
      end
    end

    describe ".resolve_attribute_default" do
      let(:resolve_attribute_default) do
        described_class.send(:resolve_attribute_default, attribute)
      end

      context "when attribute contain default" do
        let(:attribute) do
          to_mapping_hash({ base_class: "ST_Attr1", default: "1" })
        end

        it "returns the string with default value" do
          expect(resolve_attribute_default).to eql(", default: \"1\"")
        end
      end

      context "when attribute contain no default" do
        let(:attribute) { to_mapping_hash({ base_class: "ST_Attr1" }) }

        it "returns the string with nil as default value" do
          expect(resolve_attribute_default).to eql(", default: nil")
        end
      end
    end

    describe ".resolve_attribute_default_value" do
      let(:resolve_attribute_default_value) do
        described_class.send(
          :resolve_attribute_default_value,
          class_name,
          input,
        )
      end

      let(:standard_class_value) do
        {
          "int" => { input: "1", output: 1 },
          "integer" => { input: "12", output: 12 },
          "string" => { input: "test_string", output: "test_string" },
          "boolean" => { input: "false", output: false },
        }
      end

      described_class::DEFAULT_CLASSES.each do |standard_class|
        describe "for #{standard_class.capitalize} class" do
          let(:default_value) { standard_class_value[standard_class] }
          let(:class_name) { standard_class }
          let(:input) { default_value[:input] }

          it "returns an instance of #{standard_class.capitalize}" do
            expect(resolve_attribute_default_value)
              .to eql(default_value[:output])
          end
        end
      end

      context "when attribute data type is not one of the standard classes" do
        let(:class_name) { "BooleanTestClass" }
        let(:input) { "1" }

        it "returns the string with default value" do
          expect(resolve_attribute_default_value).to eql("\"1\"")
        end
      end
    end

    describe ".resolve_namespace" do
      let(:resolved_namespace) do
        described_class.send(
          :resolve_namespace,
          namespace_attrs,
        )
      end

      context "when namespace is given" do
        let(:namespace_attrs) { { namespace: "testNamespace" } }

        it "returns the string with namespace" do
          expect(resolved_namespace)
            .to eql("namespace \"testNamespace\"\n")
        end
      end

      context "when namespace and prefix are given" do
        let(:namespace_attrs) do
          {
            namespace: "testNamespace",
            prefix: "testPrefix",
          }
        end

        it "returns the string with namespace and prefix" do
          expect(resolved_namespace)
            .to eql("namespace \"testNamespace\", \"testPrefix\"\n")
        end
      end

      context "when namespace and prefix are not given" do
        it "returns the string with nil" do
          expect(described_class.send(:resolve_namespace, {})).to be_nil
        end
      end
    end
  end

  describe "required files list compiler methods" do
    let(:required_files) do
      described_class.instance_variable_get(:@required_files)
    end

    describe ".resolve_required_files" do
      context "when elements are given" do
        before do
          described_class.instance_variable_set(:@required_files, [])
        end

        after do
          described_class.instance_variable_set(:@required_files, nil)
        end

        let(:content) do
          {
            attribute_groups: {},
            complex_content: {},
            simple_content: {},
            attributes: {},
            sequence: {},
            choice: {},
            group: {},
          }
        end

        it "populates @required_files" do
          described_class.send(:resolve_required_files, content)
          expect(required_files).to eql([])
        end
      end
    end

    describe ".required_files_simple_content" do
      context "when elements are given" do
        before do
          described_class.instance_variable_set(:@required_files, [])
        end

        after do
          described_class.instance_variable_set(:@required_files, nil)
        end

        let(:content) do
          {
            extension_base: {},
            attributes: {},
            extension: {},
            restriction: {},
          }
        end

        it "populates @required_files" do
          described_class.send(:required_files_simple_content, content)
          expect(required_files).to eql([])
        end
      end
    end

    describe ".required_files_complex_content" do
      context "when elements are given" do
        before do
          described_class.instance_variable_set(:@required_files, [])
        end

        after do
          described_class.instance_variable_set(:@required_files, nil)
        end

        let(:content) do
          {
            extension: {},
            restriction: {},
          }
        end

        it "populates @required_files" do
          described_class.send(:required_files_complex_content, content)
          expect(required_files).to eql([])
        end
      end
    end

    describe ".required_files_extension" do
      context "when elements are given" do
        before do
          described_class.instance_variable_set(:@required_files, [])
        end

        after do
          described_class.instance_variable_set(:@required_files, nil)
        end

        let(:content) do
          {
            attribute_group: {},
            extension_base: {},
            attributes: {},
            attribute: {},
            sequence: {},
            choice: {},
          }
        end

        it "populates @required_files" do
          described_class.send(:required_files_extension, content)
          expect(required_files).to eql([])
        end
      end
    end

    describe ".required_files_restriction" do
      context "when elements are given" do
        before do
          described_class.instance_variable_set(:@required_files, [])
        end

        after do
          described_class.instance_variable_set(:@required_files, nil)
        end

        let(:content) { { base: "testId" } }

        it "populates @required_files" do
          described_class.send(:required_files_restriction, content)
          expect(required_files).to eql(["test_id"])
        end
      end
    end

    describe ".required_files_attribute_groups" do
      context "when elements are given" do
        before do
          described_class.instance_variable_set(:@required_files, [])
          described_class.instance_variable_set(:@attribute_groups, attribute_groups)
        end

        after do
          described_class.instance_variable_set(:@required_files, nil)
          described_class.instance_variable_set(:@attribute_groups, nil)
        end

        let(:attribute_groups) { { "testId" => {} } }

        let(:content) do
          {
            ref_class: "testId",
            attributes: {},
            attribute: {},
          }
        end

        it "populates @required_files" do
          described_class.send(:required_files_attribute_groups, content)
          expect(required_files).to eql([])
        end
      end
    end

    describe ".required_files_attribute" do
      context "when elements are given" do
        before do
          described_class.instance_variable_set(:@required_files, [])
          described_class.instance_variable_set(:@attributes, attributes)
        end

        after do
          described_class.instance_variable_set(:@required_files, nil)
          described_class.instance_variable_set(:@attributes, nil)
        end

        let(:attributes) do
          {
            "testRef" => to_mapping_hash({ base_class: "ST_Attr1" }),
          }
        end

        let(:content) do
          [
            to_mapping_hash({ ref_class: "testRef" }),
            to_mapping_hash({ base_class: "ST_Attr2" }),
          ]
        end

        it "populates @required_files" do
          described_class.send(:required_files_attribute, content)
          expect(required_files).to eql(["st_attr1", "st_attr2"])
        end
      end
    end

    describe ".required_files_choice" do
      context "when elements are given" do
        before { described_class.instance_variable_set(:@required_files, []) }
        after { described_class.instance_variable_set(:@required_files, nil) }

        let(:content) do
          {
            "testRef" => to_mapping_hash({ type_name: "ST_Attr1" }),
            sequence: {},
            element: {},
            choice: {},
            group: {},
          }
        end

        it "populates @required_files" do
          described_class.send(:required_files_choice, content)
          expect(required_files).to eql(["st_attr1"])
        end
      end
    end

    describe ".required_files_group" do
      context "when elements are given" do
        before do
          described_class.instance_variable_set(:@required_files, [])
          described_class.instance_variable_set(:@group_types, group_types)
        end

        after do
          described_class.instance_variable_set(:@required_files, nil)
          described_class.instance_variable_set(:@group_types, nil)
        end

        let(:group_types) { { "testRef" => {} } }
        let(:content) do
          {
            ref_class: "testRef",
            sequence: {},
            choice: {},
          }
        end

        it "populates @required_files" do
          described_class.send(:required_files_group, content)
          expect(required_files).to eql([])
        end
      end
    end

    describe ".required_files_sequence" do
      context "when elements are given" do
        before do
          described_class.instance_variable_set(:@required_files, [])
        end

        after do
          described_class.instance_variable_set(:@required_files, nil)
        end

        let(:content) do
          {
            elements: {},
            sequence: {},
            groups: {},
            choice: {},
          }
        end

        it "populates @required_files" do
          described_class.send(:required_files_sequence, content)
          expect(required_files).to eql([])
        end
      end
    end

    describe ".required_files_elements" do
      context "when given element's data type is not one of standard class" do
        before do
          described_class.instance_variable_set(:@required_files, [])
          described_class.instance_variable_set(:@elements, elements)
        end

        after do
          described_class.instance_variable_set(:@required_files, nil)
          described_class.instance_variable_set(:@elements, nil)
        end

        let(:elements) do
          {
            "CT_Element1" => to_mapping_hash({ type_name: "w:CT_Element1" }),
          }
        end

        let(:content) do
          [
            to_mapping_hash({ ref_class: "CT_Element1" }),
            to_mapping_hash({ type_name: "CT_Element2" }),
          ]
        end

        it "populates @required_files" do
          described_class.send(:required_files_elements, content)
          expect(required_files).to eql(["ct_element1", "ct_element2"])
        end
      end

      context "when given element's data type is one of standard class" do
        before do
          described_class.instance_variable_set(:@required_files, [])
          described_class.instance_variable_set(:@elements, elements)
        end

        after do
          described_class.instance_variable_set(:@required_files, nil)
          described_class.instance_variable_set(:@elements, nil)
        end

        let(:elements) do
          {
            "CT_Element1" => to_mapping_hash({ type_name: "w:CT_Element1" }),
            "CT_Element2" => to_mapping_hash({ type_name: "xsd:string" }),
          }
        end

        let(:content) do
          [
            to_mapping_hash({ type_name: "CT_Element1" }),
            to_mapping_hash({ ref_class: "CT_Element2" }),
          ]
        end

        it "populates @required_files excluding default classes" do
          described_class.send(:required_files_elements, content)
          expect(required_files).to eql(["ct_element1"])
        end
      end
    end
  end
end

def create_pattern_mapping(array)
  array.map { |type, text| Lutaml::Model::Xml::Element.new(type, text) }
end

def to_mapping_hash(content)
  @hash ||= Lutaml::Model::MappingHash.new
  @hash.merge(content)
end
