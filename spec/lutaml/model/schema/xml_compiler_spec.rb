require "spec_helper"
require "lutaml/model/schema"
require "lutaml/xsd"

RSpec.describe Lutaml::Model::Schema::XmlCompiler do
  describe ".to_models" do
    describe "Testing the unofficial schemas" do
      context "with valid xml schema, it generates the models" do
        before do
          described_class.to_models(schema, output_dir: dir, create_files: true)
          Dir.each_child(dir) { |child| require_relative File.expand_path("#{dir}/#{child}") }
        end

        after do
          FileUtils.rm_rf(dir)
        end

        let(:dir) { Dir.mktmpdir }

        let(:schema) { File.read("spec/fixtures/xml/test_schema.xsd") }

        let(:valid_value_xml_example) do
          <<~VALID_XML_EXAMPLE
            <CT_MathTest>
              <MathTest val="1"/>
              <MathTest1 val="1"/>
            </CT_MathTest>
          VALID_XML_EXAMPLE
        end

        let(:invalid_value_xml_example) do
          <<~INVALID_XML_EXAMPLE
            <CT_MathTest>
              <MathTest val="0"/>
              <MathTest1 val="-3"/>
            </CT_MathTest>
          INVALID_XML_EXAMPLE
        end

        it "validates if the files exist in the directory" do
          expect(File).to exist("#{dir}/ct_math_test.rb")
          expect(File).to exist("#{dir}/st_integer255.rb")
          expect(File).to exist("#{dir}/long.rb")
        end

        it "validates if the CTMathTest class is loaded" do
          expect(defined?(CTMathTest)).to eq("constant")
        end

        it "creates the model files, requires them, and tests them with valid and invalid xml" do
          expect(CTMathTest.from_xml(valid_value_xml_example).to_xml).to be_equivalent_to(valid_value_xml_example)
        end

        it "raises error when processing invalid example" do
          expect { CTMathTest.from_xml(invalid_value_xml_example) }.to raise_error(Lutaml::Model::Type::MinBoundError)
        end
      end

      context "when processing examples from classes/files generated by valid xml schema" do
        before do
          Dir.mktmpdir do |dir|
            described_class.to_models(
              File.read("spec/fixtures/xml/math_document_schema.xsd"),
              output_dir: dir,
              create_files: true,
            )
            require_relative "#{dir}/math_document"
          end
        end

        let(:valid_example) { File.read("spec/fixtures/xml/valid_math_document.xml") }
        let(:invalid_example) { File.read("spec/fixtures/xml/invalid_math_document.xml") }

        it "does not raise error with valid example and creates files" do
          expect(defined?(MathDocument)).to eq("constant")
          parsed = MathDocument.from_xml(valid_example)
          expect(parsed.title).to eql("Example Title")
          expect(parsed.ipv4_address).to eql("192.168.1.1")
          expect(parsed.to_xml).to be_equivalent_to(valid_example)
        end

        it "raises PatternNotMatchedError" do
          expect(defined?(MathDocument)).to eq("constant")
          expect { MathDocument.from_xml(invalid_example) }
            .to raise_error(Lutaml::Model::Type::PatternNotMatchedError)
        end
      end

      context "when processing example from lutaml-model#260" do
        before do
          Dir.mktmpdir do |dir|
            described_class.to_models(
              File.read("spec/fixtures/xml/address_example_260.xsd"),
              output_dir: dir,
              create_files: true,
            )
            require_relative "#{dir}/address"
          end
        end

        let(:address) do
          <<~ADD
            <Address>
              Oxford Street
              <City>London</City>
              <ZIP>E1 6AN</ZIP>
            </Address>
          ADD
        end

        it "matches parsed xml with input" do
          expect(defined?(Address)).to eq("constant")
          expect(Address.from_xml(address).to_xml).to be_equivalent_to(address)
        end
      end

      context "when processing example from files generated by schema -> product_catalog.xsd" do
        before do
          Dir.mktmpdir do |dir|
            described_class.to_models(
              File.read("spec/fixtures/xml/product_catalog.xsd"),
              output_dir: dir,
              create_files: true,
            )
            require_relative "#{dir}/product_catalog"
          end
        end

        let(:product_catalog) do
          File.read("spec/fixtures/xml/examples/valid_catalog.xml")
        end

        let(:nested_category) do
          File.read("spec/fixtures/xml/examples/nested_categories.xml")
        end

        it "confirms the ProductCatalog class is required" do
          expect(defined?(ProductCatalog)).to eq("constant")
        end

        it "confirms that the from_xml and to_xml methods successfully handles xml for valid_catalog.xml" do
          expect(ProductCatalog.from_xml(product_catalog).to_xml).to be_a(String)
        end

        it "confirms that the from_xml and to_xml methods successfully handles xml for nested_categories.xml" do
          expect(ProductCatalog.from_xml(nested_category).to_xml).to be_a(String)
        end
      end

      context "when classes are generated but files are not created" do
        let(:schema_classes_hash) do
          described_class.to_models(File.read("spec/fixtures/xml/user.xsd"))
        end

        let(:expected_classes) do
          types = described_class::SimpleType::SUPPORTED_DATA_TYPES
          types.filter_map { |name, value| name.to_s unless value[:skippable] } << "User"
        end

        it "matches the expected class names of the schema" do
          expect(schema_classes_hash.keys).to eql(expected_classes)
        end
      end

      context "when classes are generated and loaded but files are not created" do
        before do
          described_class.to_models(
            File.read("spec/fixtures/xml/user.xsd"),
            load_classes: true,
          )
        end

        let(:expected_classes) do
          %w[
            NonNegativeInteger
            PositiveInteger
            Base64Binary
            UnsignedLong
            UnsignedInt
            HexBinary
            Token
            Long
            User
          ]
        end

        let(:xml) do
          <<~XML
            <User>
              <id>1112</id>
              <age>29</age>
              <token>u9dId901dp13f</token>
            </User>
          XML
        end

        it "matches the expected class names of the schema" do
          expected_classes.each do |klass|
            expect(be_const_defined(klass)).to be_truthy
          end
          expect(User.from_xml(xml).to_xml).to be_equivalent_to(xml)
        end
      end

      context "when classes are generated and loaded but files are not created for specifications schema" do
        before { described_class.to_models(schema, load_classes: true) }

        let(:schema) { File.read("spec/fixtures/xml/specifications_schema.xsd") }

        let(:spec_xml) do
          <<~XML
            <spec>
              <title>Example Specification</title>
              <version>1.0</version>
              <status>draft</status>
            </spec>
          XML
        end

        let(:short_spec_xml) do
          <<~XML
            <shortSpec>
              <title>Example Specification</title>
              <version>1.0</version>
              <status>draft</status>
            </shortSpec>
          XML
        end

        it "successfully processes the Spec example" do
          expect(Spec.from_xml(spec_xml).to_xml).to be_equivalent_to(spec_xml)
        end

        it "successfully processes the ShortSpec example" do
          expect(ShortSpec.from_xml(short_spec_xml).to_xml).to be_equivalent_to(short_spec_xml)
        end
      end
    end

    describe "Testing the official schemas" do
      before do
        Lutaml::Model::GlobalRegister.register(Lutaml::Model::Register.new(register_id))
        Lutaml::Model::Config.default_register = register_id
      end

      after do
        Lutaml::Model::Config.default_register = :default
      end

      let(:namespaced_classes) do
        Dir.mktmpdir do |dir|
          loaded_classes.each do |name, klass|
            content = "module #{module_name}\n#{klass}\nend\n"
            File.write(File.join(dir, "#{Lutaml::Model::Utils.snake_case(name)}.rb"), content)
          end
          loaded_classes.each_key { |name| require File.join(dir, "#{Lutaml::Model::Utils.snake_case(name)}.rb") }
        end
      end

      context "when classes are generated and loaded but files are not created for OOXML schema" do
        before do
          loaded_classes.merge!(
            described_class.to_models(
              Net::HTTP.get(URI("#{schema_location}/shared-math.xsd")),
              location: schema_location,
              namespace: "http://schemas.openxmlformats.org/officeDocument/2006/math",
              prefix: "m",
            ),
          )
          namespaced_classes
        end

        let(:register_id) { :ooxml }
        let(:loaded_classes) { {} }
        let(:module_name) { "OOXML" }
        let(:schema_location) { "https://raw.githubusercontent.com/t-yuki/ooxml-xsd/refs/heads/master" }
        let(:xml) do
          <<~XML
            <m:CT_F xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math">
              <m:fPr>
                <m:type val="noBar"/>
              </m:fPr>
              <m:num>
                <m:r/>
              </m:num>
              <m:den>
                <m:r/>
              </m:den>
            </m:CT_F>
          XML
        end

        it "matches the expected class names of the schema" do
          expect(defined?(OOXML::CTOMath)).to eq("constant")
          # TODO: The error is not expected once the issue#359 is implemented.
          expect(OOXML::CTOMath.instance_variable_get(:@attributes)).to be_empty
          expect { OOXML::CTF.from_xml(xml) }.to raise_error(Lutaml::Model::IncorrectSequenceError) do |error|
            expect(error.message).to match(/does not match the expected sequence/)
          end
          expect(OOXML::CTF.instance_variable_get(:@attributes)).not_to be_empty
        end
      end

      context "when classes are generated and loaded but files are not created for UnitsML-v0.9.19 schema" do
        before do
          loaded_classes.merge!(
            described_class.to_models(
              Net::HTTP.get(URI(schema_url)),
              namespace: "http://unitsml.nist.gov/unitsml-v0.9.19",
            ),
          )
          namespaced_classes
        end

        let(:register_id) { :unitsmlv0919 }
        let(:loaded_classes) { {} }
        let(:module_name) { "UnitsMLV0919" }
        let(:schema_url) { "https://raw.githubusercontent.com/unitsml/schemas/refs/heads/main/unitsml/unitsml-v0.9.19.xsd" }
        let(:xml) do
          <<~XML
            <UnitsMLType xmlns="http://unitsml.nist.gov/unitsml-v0.9.19">
              <UnitSet>
                <Unit>
                  <UnitSystem type="SI"/>
                  <UnitName xml:lang="en">meter</UnitName>
                  <UnitSymbol type="ASCII">m</UnitSymbol>
                </Unit>
              </UnitSet>
            </UnitsMLType>
          XML
        end

        let(:detailed_xml) do
          <<~XML
            <UnitsMLType xmlns="http://unitsml.nist.gov/unitsml-v0.9.19">
              <!-- Units -->
              <UnitSet>
                <!-- Base unit: meter -->
                <Unit xml:id="u1" timeStamp="2024-06-01T00:00:00+00:00" dimensionURL="http://unitsml.nist.gov/si/length">
                  <UnitSystem name="SI" type="SI_base"/>
                  <UnitName>meter</UnitName>
                  <UnitSymbol type="ASCII">m</UnitSymbol>
                  <UnitVersionHistory>Initial definition</UnitVersionHistory>
                  <CodeListValue unitCodeValue="MTR" codeListName="UN/ECE Rec 20" codeListVersion="10A" locationURL="https://unece.org/trade/cefact/UNLOCODE-Download" organizationName="UNECE"/>
                  <RootUnits>
                    <EnumeratedRootUnit unit="meter"/>
                  </RootUnits>
                  <UnitDefinition sourceName="SI Brochure" sourceURL="https://www.bipm.org/en/publications/si-brochure">The meter is the SI unit of length.</UnitDefinition>
                  <UnitHistory>Defined as the distance light travels in vacuum in 1/299792458 seconds.</UnitHistory>
                  <UnitRemark>Most common length unit</UnitRemark>
                </Unit>

                <!-- Derived unit: meter per second -->
                <Unit xml:id="u2" timeStamp="2024-06-01T00:00:00+00:00" dimensionURL="http://unitsml.nist.gov/si/speed">
                  <UnitSystem name="SI" type="SI_derived"/>
                  <UnitName>meter per second</UnitName>
                  <UnitSymbol type="ASCII">m/s</UnitSymbol>
                  <RootUnits>
                    <EnumeratedRootUnit unit="meter"/>
                    <EnumeratedRootUnit unit="second" powerNumerator="-1"/>
                  </RootUnits>
                  <Conversions>
                    <Float64ConversionFrom xml:id="c1" initialUnit="http://example.com/units#u3" initialAddend="0.0" multiplicand="3.6" divisor="1.0" finalAddend="0.0" exact="true">
                      <ConversionNote>Convert from kilometers per hour to meters per second</ConversionNote>
                    </Float64ConversionFrom>
                  </Conversions>
                  <QuantityReference url="http://example.com/units#q2" name="speed"/>
                  <UnitDefinition>Speed unit in SI</UnitDefinition>
                </Unit>

                <!-- Non-SI unit: kilometer per hour -->
                <Unit xml:id="u3" timeStamp="2024-06-01T00:00:00+00:00" dimensionURL="http://unitsml.nist.gov/si/speed">
                  <UnitSystem name="SI" type="non-SI_accepted"/>
                  <UnitName>kilometer per hour</UnitName>
                  <UnitSymbol type="ASCII">km/h</UnitSymbol>
                  <RootUnits>
                    <EnumeratedRootUnit unit="meter" prefix="k"/>
                    <EnumeratedRootUnit unit="second" powerNumerator="-1"/>
                    <EnumeratedRootUnit unit="hour" powerNumerator="-1"/>
                  </RootUnits>
                  <Conversions>
                    <Float64ConversionFrom xml:id="c2" initialUnit="http://example.com/units#u2" initialAddend="0.0" multiplicand="1.0" divisor="3.6" finalAddend="0.0" exact="true">
                      <ConversionNote>Convert from meters per second to kilometers per hour</ConversionNote>
                    </Float64ConversionFrom>
                  </Conversions>
                  <QuantityReference url="http://example.com/units#q2" name="speed"/>
                  <UnitDefinition>Common speed unit for vehicles</UnitDefinition>
                </Unit>
              </UnitSet>

              <!-- Quantities -->
              <QuantitySet>
                <Quantity xml:id="q1" quantityType="base" dimensionURL="http://unitsml.nist.gov/si/length">
                  <QuantityName>length</QuantityName>
                  <QuantitySymbol type="ASCII">l</QuantitySymbol>
                  <UnitReference url="http://example.com/units#u1" name="meter"/>
                  <QuantityDefinition sourceName="SI Brochure" sourceURL="https://www.bipm.org/en/publications/si-brochure">Distance between two points</QuantityDefinition>
                  <QuantityRemark>SI base quantity</QuantityRemark>
                </Quantity>
                <Quantity xml:id="q2" quantityType="derived" dimensionURL="http://unitsml.nist.gov/si/speed">
                  <QuantityName>speed</QuantityName>
                  <QuantitySymbol type="ASCII">v</QuantitySymbol>
                  <UnitReference url="http://example.com/units#u2" name="meter per second"/>
                  <QuantityDefinition>Rate of change of position</QuantityDefinition>
                </Quantity>
              </QuantitySet>

              <!-- Dimensions -->
              <DimensionSet>
                <Dimension xml:id="d1">
                  <Length powerNumerator="1"/>
                </Dimension>
                <Dimension xml:id="d2">
                  <Length powerNumerator="1"/>
                  <Time powerNumerator="-1"/>
                </Dimension>
                <Dimension xml:id="d3" dimensionless="true"/>
                <Dimension xml:id="d4">
                  <Time powerNumerator="-1"/>
                  <Item itemURL="http://example.com/items#ci1" itemSymbol="e⁻" powerNumerator="1"/>
                </Dimension>
              </DimensionSet>

              <!-- Prefixes -->
              <PrefixSet>
                <Prefix xml:id="p1" prefixBase="10" prefixPower="3">
                  <PrefixName>kilo</PrefixName>
                  <PrefixSymbol type="ASCII">k</PrefixSymbol>
                </Prefix>
                <Prefix xml:id="p2" prefixBase="2" prefixPower="10">
                  <PrefixName>kibi</PrefixName>
                  <PrefixSymbol type="ASCII">Ki</PrefixSymbol>
                </Prefix>
              </PrefixSet>
            </UnitsMLType>
          XML
        end

        it "matches the converted xml with the expected xml with a short example" do
          expect(UnitsMLV0919::UnitsMLType.from_xml(xml).to_xml).to be_equivalent_to(xml)
        end

        it "matches the converted xml with the expected xml with a detailed example" do
          expect(UnitsMLV0919::UnitsMLType.from_xml(detailed_xml).to_xml).to be_equivalent_to(detailed_xml)
        end
      end

      context "when classes are generated and loaded but files are not created for UnitsML-v1.0-csd03 schema" do
        before do
          loaded_classes.merge!(
            described_class.to_models(
              Net::HTTP.get(
                URI(schema_url),
              ),
            ),
          )
          namespaced_classes
        end

        let(:register_id) { :unitsml_v1_0_csd03 }
        let(:loaded_classes) { {} }
        let(:module_name) { "UnitsMLV10CSD03" }
        let(:schema_url) { "https://raw.githubusercontent.com/unitsml/schemas/refs/heads/main/unitsml/unitsml-v1.0-csd03.xsd" }
        let(:xml) do
          <<~XML
            <UnitsMLType>
              <UnitSet>
                <Unit xml:id="U_m">
                  <UnitSystem type="SI"/>
                  <UnitName xml:lang="en">meter</UnitName>
                  <UnitSymbol type="ASCII">m</UnitSymbol>
                </Unit>
                <Unit xml:id="U_km">
                  <UnitSystem type="SI"/>
                  <UnitName xml:lang="en">kilometer</UnitName>
                  <UnitSymbol type="ASCII">km</UnitSymbol>
                </Unit>
              </UnitSet>
            </UnitsMLType>
          XML
        end

        let(:detailed_xml) do
          <<~XML
            <UnitsMLType>
              <UnitSet>
                <Unit xml:id="u_meter" timeStamp="2024-06-01T12:00:00+00:00" dimensionURL="http://unitsml.nist.gov/si/meter">
                  <UnitSystem name="SI" type="SI_base"/>
                  <UnitName xml:lang="en">meter</UnitName>
                  <UnitSymbol type="ASCII">m</UnitSymbol>
                  <CodeListValue unitCodeValue="MTR" codeListName="UN/ECE Rec 20" codeListVersion="10A" locationURL="http://www.unece.org/cefact/codesfortrade/codes_index.html" organizationName="UNECE"/>
                  <RootUnits>
                    <EnumeratedRootUnit unit="meter"/>
                  </RootUnits>
                  <UnitVersionHistory>Initial definition of the meter.</UnitVersionHistory>
                  <UnitDefinition>The meter is the SI base unit of length.</UnitDefinition>
                  <UnitHistory>Defined as the distance light travels in vacuum in 1/299792458 seconds.</UnitHistory>
                  <UnitRemark>Commonly used in science and engineering.</UnitRemark>
                </Unit>
                <Unit xml:id="u_second" timeStamp="2024-06-01T12:00:00+00:00" dimensionURL="http://unitsml.nist.gov/si/second">
                  <UnitSystem name="SI" type="SI_base"/>
                  <UnitName xml:lang="en">second</UnitName>
                  <UnitSymbol type="ASCII">s</UnitSymbol>
                  <RootUnits>
                    <EnumeratedRootUnit unit="second"/>
                  </RootUnits>
                </Unit>
                <Unit xml:id="u_newton" timeStamp="2024-06-01T12:00:00+00:00" dimensionURL="http://unitsml.nist.gov/si/newton">
                  <UnitSystem name="SI" type="SI_derived"/>
                  <UnitName xml:lang="en">newton</UnitName>
                  <UnitSymbol type="ASCII">N</UnitSymbol>
                  <RootUnits>
                    <EnumeratedRootUnit unit="meter"/>
                    <EnumeratedRootUnit unit="gram"/>
                    <EnumeratedRootUnit unit="second" powerNumerator="-2"/>
                  </RootUnits>
                  <Conversions>
                    <Float64ConversionFrom xml:id="conv1" initialUnit="http://unitsml.nist.gov/si/meter#u_gram_meter_per_second_squared" multiplicand="1.0" divisor="1.0" exact="true"/>
                  </Conversions>
                </Unit>
              </UnitSet>
            </UnitsMLType>
          XML
        end

        it "matches the converted xml with the expected xml with a short example" do
          expect(UnitsMLV10CSD03::UnitsMLType.from_xml(xml).to_xml).to be_equivalent_to(xml)
        end

        it "matches the converted xml with the expected xml with a detailed example" do
          expect(UnitsMLV10CSD03::UnitsMLType.from_xml(detailed_xml).to_xml).to be_equivalent_to(detailed_xml)
        end
      end

      context "when classes are generated and loaded but files are not created for UnitsML-v1.0-csd04 schema" do
        before do
          loaded_classes.merge!(
            described_class.to_models(
              Net::HTTP.get(
                URI(schema_url),
              ),
            ),
          )
          namespaced_classes
        end

        let(:register_id) { :unitsml_v1_0_csd04 }
        let(:loaded_classes) { {} }
        let(:module_name) { "UnitsMLV10CSD04" }
        let(:schema_url) { "https://raw.githubusercontent.com/unitsml/schemas/refs/heads/main/unitsml/unitsml-v1.0-csd04.xsd" }
        let(:xml) do
          <<~XML
            <UnitsMLType>
              <UnitSet>
                <Unit xml:id="U_m">
                  <UnitSystem type="SI"/>
                  <UnitName xml:lang="en">meter</UnitName>
                  <UnitSymbol type="ASCII">m</UnitSymbol>
                </Unit>
                <Unit xml:id="U_km">
                  <UnitSystem type="SI"/>
                  <UnitName xml:lang="en">kilometer</UnitName>
                  <UnitSymbol type="ASCII">km</UnitSymbol>
                </Unit>
              </UnitSet>
            </UnitsMLType>
          XML
        end

        let(:detailed_xml) do
          <<~XML
            <UnitsMLType>
              <UnitSet>
                <Unit xml:id="u_meter" timeStamp="2024-06-01T12:00:00+00:00" dimensionURL="http://unitsml.nist.gov/si/meter">
                  <UnitSystem name="SI" type="SI_base"/>
                  <UnitName xml:lang="en">meter</UnitName>
                  <UnitSymbol type="ASCII">m</UnitSymbol>
                  <CodeListValue unitCodeValue="MTR" codeListName="UN/ECE Rec 20" codeListVersion="10A" locationURL="http://www.unece.org/cefact/codesfortrade/codes_index.html" organizationName="UNECE"/>
                  <RootUnits>
                    <EnumeratedRootUnit unit="meter"/>
                  </RootUnits>
                  <UnitVersionHistory>Initial definition of the meter.</UnitVersionHistory>
                  <UnitDefinition>The meter is the SI base unit of length.</UnitDefinition>
                  <UnitHistory>Defined as the distance light travels in vacuum in 1/299792458 seconds.</UnitHistory>
                  <UnitRemark>Commonly used in science and engineering.</UnitRemark>
                </Unit>
                <Unit xml:id="u_second" timeStamp="2024-06-01T12:00:00+00:00" dimensionURL="http://unitsml.nist.gov/si/second">
                  <UnitSystem name="SI" type="SI_base"/>
                  <UnitName xml:lang="en">second</UnitName>
                  <UnitSymbol type="ASCII">s</UnitSymbol>
                  <RootUnits>
                    <EnumeratedRootUnit unit="second"/>
                  </RootUnits>
                </Unit>
                <Unit xml:id="u_newton" timeStamp="2024-06-01T12:00:00+00:00" dimensionURL="http://unitsml.nist.gov/si/newton">
                  <UnitSystem name="SI" type="SI_derived"/>
                  <UnitName xml:lang="en">newton</UnitName>
                  <UnitSymbol type="ASCII">N</UnitSymbol>
                  <RootUnits>
                    <EnumeratedRootUnit unit="meter"/>
                    <EnumeratedRootUnit unit="gram"/>
                    <EnumeratedRootUnit unit="second" powerNumerator="-2"/>
                  </RootUnits>
                  <Conversions>
                    <Float64ConversionFrom xml:id="conv1" initialUnit="http://unitsml.nist.gov/si/meter#u_gram_meter_per_second_squared" multiplicand="1.0" divisor="1.0" exact="true"/>
                  </Conversions>
                </Unit>
              </UnitSet>
            </UnitsMLType>
          XML
        end

        it "matches the converted xml with the expected xml with a short example" do
          expect(UnitsMLV10CSD04::UnitsMLType.from_xml(xml).to_xml).to be_equivalent_to(xml)
        end

        it "matches the converted xml with the expected xml with a detailed example" do
          expect(UnitsMLV10CSD04::UnitsMLType.from_xml(detailed_xml).to_xml).to be_equivalent_to(detailed_xml)
        end
      end
    end
  end
end
