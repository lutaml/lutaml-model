= Reference Type Documentation
:toc:
:toclevels: 3

== Overview

The Reference type in Lutaml::Model provides a powerful mechanism for creating relationships between model objects through automatic object resolution. References work transparently - you assign keys (like IDs) but get back actual resolved objects when accessing them.

== Key Features

* **Transparent Object Resolution**: Assign keys, get back resolved objects automatically
* **Memory Efficient**: Stores only reference keys during serialization
* **Type Safety**: Automatic casting and validation
* **Clean Serialization**: Serializes to keys, deserializes to resolved objects
* **Collection Support**: Works with arrays of references
* **User-Friendly**: No need to work with Reference instances directly

== Basic Usage

=== Defining Reference Attributes

Use the `ref:` syntax in attribute definitions:

[source,ruby]
----
class Author < Lutaml::Model::Serializable
  attribute :id, :string
  attribute :name, :string
  attribute :email, :string
end

class Book < Lutaml::Model::Serializable
  attribute :id, :string
  attribute :title, :string
  attribute :author_ref, { ref: ["Author", :id] }
  attribute :co_authors, { ref: ["Author", :id] }, collection: true
end
----

=== Working with References

[source,ruby]
----
# Create an author
author = Author.new(id: "author-1", name: "John Doe", email: "john@example.com")

# Create a book with a reference
book = Book.new(id: "book-1", title: "Great Book")
book.author_ref = "author-1"  # Assign the key

# Access the referenced object - automatically resolved!
puts book.author_ref.name     # => "John Doe" (returns actual Author object)
puts book.author_ref.class    # => Author
puts book.author_ref.id       # => "author-1"

# Collection of references
book.co_authors = ["author-1", "author-2"]
book.co_authors.each do |author|  # Each item is an actual Author object
  puts author.name
end
----

== Reference Syntax

=== Attribute Definition Format

[source,ruby]
----
attribute :attribute_name, { ref: [ModelClass, key_attribute] }
----

* `ModelClass`: String name of the target model class
* `key_attribute`: Symbol representing the attribute to match against

=== Examples

[source,ruby]
----
# Basic reference
attribute :user_ref, { ref: ["User", :id] }

# Reference with custom key attribute  
attribute :category_ref, { ref: ["Category", :slug] }

# Collection of references
attribute :tag_refs, { ref: ["Tag", :name] }, collection: true
----

== Serialization Behavior

The reference system provides clean, predictable serialization:

* **Assignment**: You assign string keys (like IDs)
* **Access**: You get back resolved objects automatically
* **Serialization**: Keys are serialized (not full objects)
* **Deserialization**: Keys are deserialized and resolved to objects

=== Serialization Examples

[source,ruby]
----
book.author_ref = "author-1"
book.co_authors = ["author-1", "author-2"]

# Accessing returns resolved objects
book.author_ref.name        # => "John Doe"
book.co_authors.first.name  # => "John Doe"

# Serialization outputs keys only
book.to_yaml   # => author_ref: author-1
book.to_json   # => {"author_ref": "author-1", ...}
book.to_hash   # => {"author_ref" => "author-1", ...}
----

=== YAML Serialization

[source,ruby]
----
book = Book.new(id: "book-1", title: "Sample Book")
book.author_ref = "author-1"

# Serializes to clean YAML
yaml_output = book.to_yaml
# =>
# id: book-1
# title: Sample Book  
# author_ref: author-1

# Deserializes back to resolved objects
loaded_book = Book.from_yaml(yaml_output)
loaded_book.author_ref        # => Author instance (not Reference!)
loaded_book.author_ref.name   # => "John Doe" 
----

=== JSON Serialization

[source,ruby]
----
json_output = book.to_json
# => {"id":"book-1","title":"Sample Book","author_ref":"author-1"}

loaded_book = Book.from_json(json_output)
loaded_book.author_ref        # => Author instance (resolved automatically)
loaded_book.author_ref.name   # => "John Doe"
----

== Advanced Usage

=== Custom Key Attributes

References can use any attribute as the key, not just `:id`.

[source,ruby]
----
class Category < Lutaml::Model::Serializable
  attribute :slug, :string
  attribute :name, :string
end

class Product < Lutaml::Model::Serializable
  attribute :id, :string
  attribute :category_ref, { ref: ["Category", :slug] }
end

# Usage
category = Category.new(slug: "electronics", name: "Electronics")
product = Product.new(id: "p1")
product.category_ref = "electronics"  # References by slug, not id
----

=== Nested References

References work in nested structures and collections.

[source,ruby]
----
class Comment < Lutaml::Model::Serializable
  attribute :id, :string
  attribute :content, :string
  attribute :author_ref, { ref: ["User", :id] }
  attribute :replies, { ref: ["Comment", :id] }, collection: true
end

comment = Comment.new(id: "c1", content: "Great post!")
comment.author_ref = "user-1"
comment.replies = ["c2", "c3"]  # References to other comments
----

=== Validation and Error Handling

[source,ruby]
----
# Invalid reference specification raises ArgumentError
begin
  Class.new(Lutaml::Model::Serializable) do
    attribute :invalid_ref, { ref: "NotAnArray" }
  end
rescue ArgumentError => e
  puts e.message  # => "ref: syntax requires an array [model_class, key_attribute]"
end
----
