= Best practices

== Namespace practices

=== Use XmlNamespace classes for structured projects

**Do:**

[source,ruby]
----
# Define namespace once
class ProjectNamespace < Lutaml::Model::XmlNamespace
  uri 'https://example.com/project/v1'
  prefix_default 'proj'
  element_form_default :qualified
  version '1.0'
  documentation "Project schema"
end

# Reuse across many models
class Model1 < Lutaml::Model::Serializable
  xml do
    element 'model1'
    namespace ProjectNamespace
  end
end

class Model2 < Lutaml::Model::Serializable
  xml do
    element 'model2'
    namespace ProjectNamespace
  end
end
----

**Don't:**

[source,ruby]
----
# Repeat namespace details in every model
class Model1 < Lutaml::Model::Serializable
  xml do
    root 'model1'
    namespace 'https://example.com/project/v1', 'proj'
  end
end

class Model2 < Lutaml::Model::Serializable
  xml do
    root 'model2'
    namespace 'https://example.com/project/v1', 'proj'
  end
end
----

=== Follow W3C qualification conventions

**Do:**

[source,ruby]
----
class MyNamespace < Lutaml::Model::XmlNamespace
  uri 'https://example.com/schema'
  prefix_default 'pfx'
  element_form_default :qualified    # Typical for complex schemas
  attribute_form_default :unqualified  # W3C convention
end
----

**Don't:**

[source,ruby]
----
# Avoid qualifying attributes unless absolutely necessary
class MyNamespace < Lutaml::Model::XmlNamespace
  attribute_form_default :qualified  # Unusual, avoid unless required
end
----

=== Use meaningful namespace URIs

**Do:**

[source,ruby]
----
class ContactNamespace < Lutaml::Model::XmlNamespace
  uri 'https://example.com/schemas/contact/v1'  # Versioned, descriptive
  schema_location 'https://example.com/schemas/contact/v1/contact.xsd'
end
----

**Don't:**

[source,ruby]
----
class ContactNamespace < Lutaml::Model::XmlNamespace
  uri 'http://example.com'  # Too generic
  uri 'urn:x-example:contact'  # Non-standard format without good reason
end
----

== Element declaration practices

=== Use `element()` for new code

**Do:**

[source,ruby]
----
class Model < Lutaml::Model::Serializable
  xml do
    element 'model'  # Clear, modern API
    map_element 'attr', to: :attr
  end
end
----

**Acceptable:**

[source,ruby]
----
class Model < Lutaml::Model::Serializable
  xml do
    root 'model'  # Backward compatible, still works
    map_element 'attr', to: :attr
  end
end
----

=== Omit element declaration for type-only models

**Do:**

[source,ruby]
----
class Address < Lutaml::Model::Serializable
  attribute :street, :string
  attribute :city, :string

  xml do
    # No element() - embedded type only
    sequence do
      map_element 'street', to: :street
      map_element 'city', to: :city
    end
  end
end
----

**Don't:**

[source,ruby]
----
class Address < Lutaml::Model::Serializable
  xml do
    no_root  # DEPRECATED
    map_element 'street', to: :street
  end
end
----

== Mixed content practices

=== Use explicit `mixed_content()` for clarity

**Do:**

[source,ruby]
----
class RichText < Lutaml::Model::Serializable
  xml do
    element 'text'
    mixed_content  # Explicit and clear
    map_element 'b', to: :bold
  end
end
----

**Acceptable:**

[source,ruby]
----
class RichText < Lutaml::Model::Serializable
  xml do
    root 'text', mixed: true # Also works
    map_element 'b', to: :bold
  end
end
----

== Sequence practices

=== Use sequence when order matters

**Do:**

[source,ruby]
----
class Person < Lutaml::Model::Serializable
  xml do
    element 'person'
    sequence do  # Enforce strict order
      map_element 'firstName', to: :first_name
      map_element 'lastName', to: :last_name
      map_element 'email', to: :email
    end
  end
end
----

**Don't:**

[source,ruby]
----
# Without sequence when order is important per XSD
class Person < Lutaml::Model::Serializable
  xml do
    element 'person'
    # Elements can appear in any order - may not match XSD
    map_element 'firstName', to: :first_name
    map_element 'lastName', to: :last_name
  end
end
----

== XSD generation practices

=== Add documentation for generated schemas

**Do:**

[source,ruby]
----
class ContactNamespace < Lutaml::Model::XmlNamespace
  uri 'https://example.com/contact/v1'
  version '1.0'
  documentation "Contact information schema for Example Corp"
end

class Contact < Lutaml::Model::Serializable
  xml do
    element 'contact'
    namespace ContactNamespace
    documentation "Represents a contact record"
    type_name 'ContactRecordType'
  end
end
----

**Don't:**

[source,ruby]
----
# Missing documentation makes generated XSD less useful
class Contact < Lutaml::Model::Serializable
  xml do
    element 'contact'
  end
end
----

=== Use explicit xsd_type for special cases

**Do:**

[source,ruby]
----
class Product < Lutaml::Model::Serializable
  attribute :product_id, :string, xsd_type: 'xs:ID'
  attribute :parent_ref, :string, xsd_type: 'xs:IDREF'

  xml do
    element 'product'
    map_attribute 'id', to: :product_id
    map_attribute 'parentRef', to: :parent_ref
  end
end
----

**Don't:**

[source,ruby]
----
# Rely on default inference for ID/IDREF relationships
class Product < Lutaml::Model::Serializable
  attribute :product_id, :string  # Won't generate xs:ID
  attribute :parent_ref, :string  # Won't generate xs:IDREF
end
----

== Qualification practices

=== Be consistent within a schema

**Do:**

[source,ruby]
----
class MyNamespace < Lutaml::Model::XmlNamespace
  uri 'https://example.com/schema'
  element_form_default :qualified  # Set once, applies to all
end

# All models using this namespace follow the same rules
class Model1 < Lutaml::Model::Serializable
  xml do
    element 'model1'
    namespace MyNamespace
  end
end

class Model2 < Lutaml::Model::Serializable
  xml do
    element 'model2'
    namespace MyNamespace
  end
end
----

**Don't:**

[source,ruby]
----
# Inconsistent qualification creates confusion
class Model1 < Lutaml::Model::Serializable
  xml do
    element 'model1'
    namespace 'https://example.com/schema', 'pfx'
    map_element 'attr', to: :attr, form: :qualified
  end
end

class Model2 < Lutaml::Model::Serializable
  xml do
    element 'model2'
    namespace 'https://example.com/schema', 'pfx'
    map_element 'attr', to: :attr, form: :unqualified
  end
end
----

=== Use `form:` sparingly

**Do:**

[source,ruby]
----
# Set namespace-level defaults, override only when needed
class MyNamespace < Lutaml::Model::XmlNamespace
  element_form_default :qualified
end

class Model < Lutaml::Model::Serializable
  xml do
    namespace MyNamespace
    map_element 'special', to: :special, form: :unqualified  # Exception
    map_element 'normal', to: :normal  # Uses default
  end
end
----

**Don't:**

[source,ruby]
----
# Overriding form on every element defeats namespace defaults
class Model < Lutaml::Model::Serializable
  xml do
    namespace MyNamespace
    map_element 'attr1', to: :attr1, form: :qualified
    map_element 'attr2', to: :attr2, form: :qualified
    map_element 'attr3', to: :attr3, form: :qualified
    # Just set element_form_default :qualified instead!
  end
end
----

== Encoding practices

=== Set encoding explicitly for non-UTF-8

**Do:**

[source,ruby]
----
# Per-instance for consistent encoding
instance = JapaneseCeramic.new(glaze_type: "志野釉")
instance.encoding = "Shift_JIS"
xml = instance.to_xml

# Or per-export when needed
xml = instance.to_xml(encoding: "Shift_JIS")
----

**Don't:**

[source,ruby]
----
# Rely on defaults for non-UTF-8 data
instance = JapaneseCeramic.new(glaze_type: "志野釉")
xml = instance.to_xml  # May produce corrupted output with some adapters
----

== Testing practices

=== Test round-trip serialization

**Do:**

[source,ruby]
----
RSpec.describe Contact do
  it "round-trips correctly" do
    original = Contact.new(name: "John", email: "john@example.com")
    xml = original.to_xml
    parsed = Contact.from_xml(xml)

    expect(parsed).to eq(original)
    expect(parsed.name).to eq("John")
    expect(parsed.email).to eq("john@example.com")
  end
end
----

=== Test namespace presence

**Do:**

[source,ruby]
----
RSpec.describe Contact do
  it "includes correct namespace" do
    contact = Contact.new(name: "John")
    xml = contact.to_xml

    expect(xml).to include('xmlns:contact=')
    expect(xml).to include('https://example.com/schemas/contact/v1')
  end
end
----

=== Test XSD generation if using

**Do:**

[source,ruby]
----
RSpec.describe "XSD generation" do
  it "generates valid XSD" do
    xsd = Lutaml::Model::Schema.to_xml(Contact)

    expect(xsd).to include('<xs:schema')
    expect(xsd).to include('targetNamespace')
    expect(xsd).to include('ContactRecordType')
  end
end
----

== Performance practices

=== Choose appropriate adapter

**XML adapters:**

* **Ox**: Fastest, use for performance-critical applications
* **Nokogiri**: Most compatible, good balance
* **Oga**: Pure Ruby, works with Opal, use when no native extensions allowed

**Configure once:**

[source,ruby]
----
Lutaml::Model::Config.configure do |config|
  config.xml_adapter_type = :ox  # or :nokogiri, :oga
end
----

=== Avoid excessive nesting

**Do:**

[source,ruby]
----
# Flat structure when possible
class Address < Lutaml::Model::Serializable
  attribute :street, :string
  attribute :city, :string
  attribute :postal_code, :string
end
----

**Avoid when unnecessary:**

[source,ruby]
----
# Unnecessary nesting
class Street < Lutaml::Model::Serializable
  attribute :name, :string
end

class City < Lutaml::Model::Serializable
  attribute :name, :string
end

class Address < Lutaml::Model::Serializable
  attribute :street, Street
  attribute :city, City
  # Just use :string attributes directly
end
----

== Organization practices

=== Group related namespace classes

**Do:**

[source,ruby]
----
# lib/my_project/namespaces.rb
module MyProject
  module Namespaces
    class Contact < Lutaml::Model::XmlNamespace
      uri 'https://example.com/contact/v1'
      prefix_default 'contact'
    end

    class Address < Lutaml::Model::XmlNamespace
      uri 'https://example.com/address/v1'
      prefix_default 'addr'
    end
  end
end
----

=== Separate models by domain

**Do:**

[source,ruby]
----
# lib/my_project/models/contact.rb
class Contact < Lutaml::Model::Serializable
  # ...
end

# lib/my_project/models/address.rb
class Address < Lutaml::Model::Serializable
  # ...
end
----

== Documentation practices

=== Document complex mappings

**Do:**

[source,ruby]
----
class ComplexModel < Lutaml::Model::Serializable
  # This attribute maps to either 'type' or 'kind' element
  # depending on schema version
  attribute :type_info, :string

  xml do
    element 'model'
    # Map multiple names for backward compatibility
    map_element ['type', 'kind'], to: :type_info
  end
end
----

=== Add XSD documentation

**Do:**

[source,ruby]
----
class Contact < Lutaml::Model::Serializable
  xml do
    element 'contact'
    documentation "Represents a contact with name and email"

    map_element 'name', to: :name
    map_element 'email', to: :email
  end
end
----

== Error handling practices

=== Validate after parsing

**Do:**

[source,ruby]
----
xml = get_xml_from_source()
contact = Contact.from_xml(xml)
contact.validate!  # Raises if invalid

# Or silent validation
errors = contact.validate
if errors.any?
  handle_errors(errors)
end
----

=== Use appropriate error types

**Do:**

[source,ruby]
----
begin
  Contact.from_xml(invalid_xml)
rescue Lutaml::Model::InvalidFormatError => e
  # Handle parse errors
rescue Lutaml::Model::ValidationError => e
  # Handle validation errors
rescue Lutaml::Model::NoRootMappingError => e
  # Handle type-only model parsing attempts
end
----

== Schema versioning practices

=== Include version in namespace URI

**Do:**

[source,ruby]
----
class ContactNamespace < Lutaml::Model::XmlNamespace
  uri 'https://example.com/schemas/contact/v1'  # Version in URI
  version '1.0'  # Also track in metadata
end
----

=== Support multiple versions

**Do:**

[source,ruby]
----
class ContactNamespaceV1 < Lutaml::Model::XmlNamespace
  uri 'https://example.com/schemas/contact/v1'
  version '1.0'
end

class ContactNamespaceV2 < Lutaml::Model::XmlNamespace
  uri 'https://example.com/schemas/contact/v2'
  version '2.0'
end

# Models can explicitly choose version
class LegacyContact < Lutaml::Model::Serializable
  xml do
    element 'contact'
    namespace ContactNamespaceV1
  end
end

class ModernContact < Lutaml::Model::Serializable
  xml do
    element 'contact'
    namespace ContactNamespaceV2
  end
end
----

== Code style practices

=== Follow consistent indentation

**Do:**

[source,ruby]
----
class Model < Lutaml::Model::Serializable
  attribute :name, :string

  xml do
    element 'model'
    namespace MyNamespace

    sequence do
      map_element 'name', to: :name
    end
  end
end
----

=== Group related mappings

**Do:**

[source,ruby]
----
class Model < Lutaml::Model::Serializable
  xml do
    element 'model'
    namespace MyNamespace

    # Attributes first
    map_attribute 'id', to: :id
    map_attribute 'version', to: :version

    # Then elements in logical order
    sequence do
      map_element 'name', to: :name
      map_element 'description', to: :description
    end
  end
end
----

== Summary checklist

When writing XML mappings:

* ☑ Use XmlNamespace classes for projects with multiple models
* ☑ Use `element()` for new code (or `root()` for backward compat)
* ☑ Omit element declaration for type-only models (no `no_root`)
* ☑ Set `element_form_default :qualified` for complex schemas
* ☑ Keep `attribute_form_default :unqualified` (W3C convention)
* ☑ Use `sequence` when element order is significant
* ☑ Add `documentation` for XSD generation
* ☑ Specify `xsd_type` for ID/IDREF and custom XSD types
* ☑ Test round-trip serialization
* ☑ Validate parsed data
* ☑ Set encoding explicitly for non-UTF-8 data
* ☑ Choose appropriate XML adapter for your needs