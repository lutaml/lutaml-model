= Common patterns

== Basic element and attribute mapping

=== Simple model with elements

.Basic ceramic model with element mappings
[example]
====
[source,ruby]
----
class Ceramic < Lutaml::Model::Serializable
  attribute :name, :string
  attribute :description, :string
  attribute :temperature, :integer

  xml do
    root 'ceramic'
    map_element 'name', to: :name
    map_attribute 'temperature', to: :temperature
    map_content to: :description
  end
end
----

[source,xml]
----
<ceramic temperature="1200">
  <name>Porcelain Vase</name>
  with celadon glaze.
</ceramic>
----

[source,ruby]
----
> Ceramic.from_xml(xml)
> #<Ceramic @name="Porcelain Vase",
   @description=" with celadon glaze.",
   @temperature=1200>
----
====

=== Nested models

.Model with nested object
[example]
====
[source,ruby]
----
class Glaze < Lutaml::Model::Serializable
  attribute :color, :string
  attribute :temperature, :integer

  xml do
    root 'Glaze'
    map_element 'color', to: :color
    map_element 'temperature', to: :temperature
  end
end

class Ceramic < Lutaml::Model::Serializable
  attribute :type, :string
  attribute :glaze, Glaze

  xml do
    root 'Ceramic'
    map_element 'Type', to: :type
    map_element 'Glaze', to: :glaze
  end
end
----

[source,xml]
----
<Ceramic>
  <Type>Porcelain</Type>
  <Glaze>
    <color>Clear</color>
    <temperature>1050</temperature>
  </Glaze>
</Ceramic>
----
====

== Namespace patterns

=== Single namespace

.Model with single namespace
[example]
====
[source,ruby]
----
class Ceramic < Lutaml::Model::Serializable
  attribute :type, :string
  attribute :glaze, :string

  xml do
    root 'Ceramic'
    namespace 'http://example.com/ceramic'
    map_element 'Type', to: :type
    map_element 'Glaze', to: :glaze
  end
end
----

[source,xml]
----
<Ceramic xmlns='http://example.com/ceramic'>
  <Type>Porcelain</Type>
  <Glaze>Clear</Glaze>
</Ceramic>
----
====

=== Prefixed namespace

.Model with prefixed namespace
[example]
====
[source,ruby]
----
class Ceramic < Lutaml::Model::Serializable
  attribute :type, :string
  attribute :glaze, :string

  xml do
    root 'Ceramic'
    namespace 'http://example.com/ceramic', 'cer'
    map_element 'Type', to: :type
    map_element 'Glaze', to: :glaze
  end
end
----

[source,xml]
----
<cer:Ceramic xmlns:cer='http://example.com/ceramic'>
  <cer:Type>Porcelain</cer:Type>
  <cer:Glaze>Clear</cer:Glaze>
</cer:Ceramic>
----
====

=== Multi-namespace with XmlNamespace class

.Model using multiple namespaces with XmlNamespace classes
[example]
====
[source,ruby]
----
class CeramicNamespace < Lutaml::Model::XmlNamespace
  uri 'https://example.com/ceramic'
  prefix_default 'cer'
end

class GlazeNamespace < Lutaml::Model::XmlNamespace
  uri 'https://example.com/glaze'
  prefix_default 'glz'
end

class Ceramic < Lutaml::Model::Serializable
  attribute :type, :string
  attribute :glaze, :string

  xml do
    element 'ceramic'
    namespace CeramicNamespace

    map_element 'type', to: :type
    map_element 'glaze', to: :glaze,
      namespace: GlazeNamespace
  end
end
----

[source,xml]
----
<cer:ceramic xmlns:cer="https://example.com/ceramic"
             xmlns:glz="https://example.com/glaze">
  <type>Porcelain</type>
  <glz:glaze>Celadon</glz:glaze>
</cer:ceramic>
----
====

=== Namespace inheritance pattern

.Element explicitly inheriting parent namespace
[example]
====
[source,ruby]
----
class CeramicNamespace < Lutaml::Model::XmlNamespace
  uri 'https://example.com/ceramic'
  prefix_default 'cer'
  element_form_default :unqualified
end

class Ceramic < Lutaml::Model::Serializable
  attribute :type, :string
  attribute :special_type, :string

  xml do
    element 'ceramic'
    namespace CeramicNamespace

    map_element 'type', to: :type
    # Force this to inherit parent namespace
    map_element 'specialType', to: :special_type, namespace: :inherit
  end
end
----

[source,xml]
----
<cer:ceramic xmlns:cer="https://example.com/ceramic">
  <type>Porcelain</type>
  <cer:specialType>Fine</cer:specialType>
</cer:ceramic>
----
====

== Rich content patterns

=== Mixed content

.Model with mixed content (text + elements)
[example]
====
[source,ruby]
----
class Paragraph < Lutaml::Model::Serializable
  attribute :bold, :string, collection: true
  attribute :italic, :string

  xml do
    root 'p', mixed: true
    map_element 'bold', to: :bold
    map_element 'i', to: :italic
  end
end
----

[source,xml]
----
<p>My name is <bold>John Doe</bold>, and I'm <i>28</i> years old</p>
----

[source,ruby]
----
> Paragraph.from_xml(xml)
> #<Paragraph @bold="John Doe", @italic="28">
----
====

=== Ordered content

.Model preserving element order
[example]
====
[source,ruby]
----
class RootOrderedContent < Lutaml::Model::Serializable
  attribute :bold, :string
  attribute :italic, :string
  attribute :underline, :string

  xml do
    root "RootOrderedContent", ordered: true
    map_element :bold, to: :bold
    map_element :italic, to: :italic
    map_element :underline, to: :underline
  end
end
----

[source,xml]
----
<RootOrderedContent>
  <underline>Moon</underline>
  <italic>384,400 km</italic>
  <bold>bell</bold>
</RootOrderedContent>
----

When serialized back, the order is preserved:

[source,ruby]
----
> instance = RootOrderedContent.from_xml(xml)
> instance.to_xml
> #<RootOrderedContent>
    <underline>Moon</underline>
    <italic>384,400 km</italic>
    <bold>bell</bold>
  </RootOrderedContent>
----
====

== Sequence patterns

=== Basic sequence

.Model with strict element ordering
[example]
====
[source,ruby]
----
class Kiln < Lutaml::Model::Serializable
  attribute :id, :string
  attribute :name, :string
  attribute :type, :string
  attribute :color, :string

  xml do
    sequence do
      map_element :id, to: :id
      map_element :name, to: :name
      map_element :type, to: :type
      map_element :color, to: :color
    end
  end
end
----

[source,xml]
----
<collection>
  <kiln>
    <id>1</id>
    <name>Nick</name>
    <type>Hard</type>
    <color>Black</color>
  </kiln>
</collection>
----

If elements appear out of order, an error is raised.
====

=== Sequence with namespace

.Combining sequence with namespace and XmlNamespace class
[example]
====
[source,ruby]
----
class ContactNamespace < Lutaml::Model::XmlNamespace
  uri 'https://example.com/schemas/contact/v1'
  prefix_default 'contact'
  element_form_default :qualified
end

class Person < Lutaml::Model::Serializable
  attribute :name, :string
  attribute :email, :string

  xml do
    element "person"
    namespace ContactNamespace

    sequence do
      map_element "name", to: :name
      map_element "email", to: :email
    end
  end
end
----

[source,xml]
----
<contact:person xmlns:contact="https://example.com/schemas/contact/v1">
  <contact:name>John Doe</contact:name>
  <contact:email>john@example.com</contact:email>
</contact:person>
----
====

== Type-only models (no element)

=== Embedded type pattern

.Type-only model used within parent
[example]
====
[source,ruby]
----
# Type-only model - no element() or root() call
class Address < Lutaml::Model::Serializable
  attribute :street, :string
  attribute :city, :string
  attribute :postal_code, :string

  xml do
    # No element declaration - this is a type-only model
    sequence do
      map_element 'street', to: :street
      map_element 'city', to: :city
      map_element 'postalCode', to: :postal_code
    end
  end
end

# Parent model using the type
class Contact < Lutaml::Model::Serializable
  attribute :name, :string
  attribute :address, Address

  xml do
    element 'contact'

    sequence do
      map_element 'name', to: :name
      map_element 'address', to: :address
    end
  end
end
----

[source,xml]
----
<contact>
  <name>John Doe</name>
  <address>
    <street>123 Main St</street>
    <city>Metropolis</city>
    <postalCode>12345</postalCode>
  </address>
</contact>
----
====

== CDATA patterns

=== Forcing CDATA output

.Using cdata option to preserve special characters
[example]
====
[source,ruby]
----
class Example < Lutaml::Model::Serializable
  attribute :name, :string
  attribute :description, :string
  attribute :title, :string
  attribute :note, :string

  xml do
    root 'example'
    map_element :name, to: :name, cdata: true
    map_content to: :description, cdata: true
    map_element :title, to: :title, cdata: false
    map_element :note, to: :note, cdata: false
  end
end
----

[source,xml]
----
<example>
  <name><![CDATA[John]]></name>
  <![CDATA[here is the description]]>
  <title>Lutaml</title>
  <note>Careful</note>
</example>
----
====

== XSD generation patterns

=== Basic XSD generation

.Generating XSD from model
[example]
====
[source,ruby]
----
class Contact < Lutaml::Model::Serializable
  attribute :name, :string
  attribute :email, :string

  xml do
    element 'contact'
    map_element 'name', to: :name
    map_element 'email', to: :email
  end
end

# Generate XSD
xsd = Lutaml::Model::Schema.to_xml(Contact)
puts xsd
----
====

=== XSD with namespace and documentation

.Complete XSD generation with metadata
[example]
====
[source,ruby]
----
class ContactNamespace < Lutaml::Model::XmlNamespace
  uri 'https://example.com/schemas/contact/v1'
  schema_location 'https://example.com/schemas/contact/v1/contact.xsd'
  prefix_default 'contact'
  element_form_default :qualified
  version '1.0'
  documentation "Contact information schema"
end

class Contact < Lutaml::Model::Serializable
  attribute :name, :string
  attribute :email, :string

  xml do
    element 'contact'
    namespace ContactNamespace
    documentation "A contact record"

    sequence do
      map_element 'name', to: :name
      map_element 'email', to: :email
    end
  end
end

# Generate XSD with options
xsd = Lutaml::Model::Schema.to_xml(
  Contact,
  namespace: ContactNamespace.uri,
  prefix: ContactNamespace.prefix_default,
  output_dir: 'schemas',
  create_files: true
)
----
====

== Qualification patterns

=== Qualified elements pattern

.All elements namespace-qualified
[example]
====
[source,ruby]
----
class CeramicNamespace < Lutaml::Model::XmlNamespace
  uri 'https://example.com/ceramic'
  prefix_default 'cer'
  element_form_default :qualified  # All local elements qualified
end

class Ceramic < Lutaml::Model::Serializable
  attribute :type, :string
  attribute :color, :string

  xml do
    element 'ceramic'
    namespace CeramicNamespace

    map_element 'type', to: :type
    map_element 'color', to: :color
  end
end
----

[source,xml]
----
<cer:ceramic xmlns:cer="https://example.com/ceramic">
  <cer:type>Porcelain</cer:type>
  <cer:color>White</cer:color>
</cer:ceramic>
----
====

=== Selective qualification

.Override qualification for specific elements
[example]
====
[source,ruby]
----
class CeramicNamespace < Lutaml::Model::XmlNamespace
  uri 'https://example.com/ceramic'
  prefix_default 'cer'
  element_form_default :unqualified  # Default: unqualified
end

class Ceramic < Lutaml::Model::Serializable
  attribute :type, :string
  attribute :glaze, :string
  attribute :id, :string

  xml do
    element 'ceramic'
    namespace CeramicNamespace

    # Override to qualified
    map_element 'type', to: :type, form: :qualified
    # Use default (unqualified)
    map_element 'glaze', to: :glaze
    # Force attribute qualified
    map_attribute 'id', to: :id, form: :qualified
  end
end
----

[source,xml]
----
<cer:ceramic xmlns:cer="https://example.com/ceramic" cer:id="C001">
  <cer:type>Porcelain</cer:type>
  <glaze>Clear</glaze>
</cer:ceramic>
----
====

== Collection patterns

=== Element collections

.Model with element collection
[example]
====
[source,ruby]
----
class CeramicCollection < Lutaml::Model::Serializable
  attribute :items, Ceramic, collection: true

  xml do
    root 'ceramics'
    map_element 'ceramic', to: :items
  end
end
----

[source,xml]
----
<ceramics>
  <ceramic>...</ceramic>
  <ceramic>...</ceramic>
  <ceramic>...</ceramic>
</ceramics>
----
====

=== Attribute collections with delimiter

.XML attribute containing delimited values
[example]
====
[source,ruby]
----
class TitleCollection < Lutaml::Model::Collection
  instances :items, :string

  xml do
    root "titles"
    map_attribute "title", to: :items, delimiter: "; "
  end
end
----

[source,xml]
----
<titles title="Title One; Title Two; Title Three"/>
----

[source,ruby]
----
collection = TitleCollection.from_xml(xml)
collection.items
# => ["Title One", "Title Two", "Title Three"]
----
====

== Character encoding patterns

=== Per-instance encoding

.Setting encoding on model instance
[example]
====
[source,ruby]
----
class JapaneseCeramic < Lutaml::Model::Serializable
  attribute :glaze_type, :string
  attribute :description, :string

  xml do
    root 'JapaneseCeramic'
    map_attribute 'glazeType', to: :glaze_type
    map_element 'description', to: :description
  end
end

# Create instance with UTF-8 data
instance = JapaneseCeramic.new(
  glaze_type: "志野釉",
  description: "東京国立博物館コレクション"
)

# Set character encoding to Shift_JIS
instance.encoding = "Shift_JIS"

# Serialize with specified encoding
serialization_output = instance.to_xml
----
====

=== Per-export encoding

.Setting encoding during serialization
[example]
====
[source,ruby]
----
ceramic_instance = Ceramic.new(
  potter: "John & Jane",
  description: " A ∑ series of ∏ porcelain µ vases."
)

# Using default encoding of UTF-8
ceramic_instance.to_xml
# => <ceramic><potter>John &amp; Jane</potter> A ∑ series...</ceramic>

# Using ASCII encoding
ceramic_instance.to_xml(encoding: "ASCII")
# => <ceramic><potter>John &amp; Jane</potter> A &#8721; series...</ceramic>
----
====

== Import patterns with sequence

=== Importing mappings in sequence

.Using import_model_mappings inside sequence
[example]
====
[source,ruby]
----
class Address < Lutaml::Model::Serializable
  attribute :street, :string
  attribute :city, :string
  attribute :zip, :string

  xml do
    no_root

    map_element :street, to: :street
    map_element :city, to: :city
    map_element :zip, to: :zip
  end
end

class Person < Lutaml::Model::Serializable
  attribute :name, :string
  import_model_attributes Address

  xml do
    root "Person"

    map_element :name, to: :name
    sequence do
      import_model_mappings Address
    end
  end
end
----

[source,xml]
----
<Person>
  <name>John Doe</name>
  <street>123 Main St</street>
  <city>Metropolis</city>
  <zip>12345</zip>
</Person>
----
====

== XSD type override patterns

=== Using xsd_type for IDs

.Specify XSD types for ID/IDREF
[example]
====
[source,ruby]
----
class Product < Lutaml::Model::Serializable
  attribute :product_id, :string, xsd_type: 'xs:ID'
  attribute :category_ref, :string, xsd_type: 'xs:IDREF'

  xml do
    element 'product'
    map_attribute 'id', to: :product_id
    map_attribute 'categoryRef', to: :category_ref
  end
end

# Generated XSD:
# <xs:attribute name="id" type="xs:ID"/>
# <xs:attribute name="categoryRef" type="xs:IDREF"/>
----
====

=== Using xsd_type for custom types

.Override automatic XSD type inference
[example]
====
[source,ruby]
----
class Document < Lutaml::Model::Serializable
  attribute :language, :string, xsd_type: 'xs:language'
  attribute :content_type, :string, xsd_type: 'xs:token'

  xml do
    element 'document'
    map_attribute 'lang', to: :language
    map_attribute 'contentType', to: :content_type
  end
end
----
====

== Type-level namespace pattern

=== Type with own namespace

.Custom type declaring its namespace
[example]
====
[source,ruby]
----
# Define namespace for email types
class EmailNamespace < Lutaml::Model::XmlNamespace
  uri 'https://example.com/types/email'
  prefix_default 'email'
end

# Define type with namespace
class EmailType < Lutaml::Model::Type::String
  namespace EmailNamespace  # <1>
  xsd_type 'EmailAddress'   # <2>

  def self.cast(value)
    email = super(value)
    unless email.match?(/\A[\w+\-.]+@[a-z\d\-]+(\.[a-z\d\-]+)*\.[a-z]+\z/i)
      raise Lutaml::Model::TypeError, "Invalid email: #{email}"
    end
    email.downcase
  end
end

class Contact < Lutaml::Model::Serializable
  attribute :email, EmailType

  xml do
    element 'contact'
    namespace 'https://example.com/contact', 'c'

    map_element 'email', to: :email  # Uses EmailNamespace from EmailType
  end
end

contact = Contact.new(email: "USER@EXAMPLE.COM")
puts contact.to_xml
# => <c:contact xmlns:c="https://example.com/contact"
#               xmlns:email="https://example.com/types/email">
#      <email:email>user@example.com</email:email>
#    </c:contact>

# Round-trip deserialization works
parsed = Contact.from_xml(contact.to_xml)
parsed.email  # => "user@example.com"
----
<1> Namespace directive associates EmailNamespace with this type
<2> XSD type name for schema generation
====

=== Multi-namespace document with Type namespaces

.Dublin Core metadata in document
[example]
====
[source,ruby]
----
# Define namespaces
class DocumentNamespace < Lutaml::Model::XmlNamespace
  uri 'https://example.com/document'
  prefix_default 'doc'
end

class DublinCoreNamespace < Lutaml::Model::XmlNamespace
  uri 'http://purl.org/dc/elements/1.1/'
  prefix_default 'dc'
end

# Define DC types with namespaces
class DcTitleType < Lutaml::Model::Type::String
  xml_namespace DublinCoreNamespace
  xsd_type 'titleType'
end

class DcCreatorType < Lutaml::Model::Type::String
  xml_namespace DublinCoreNamespace
  xsd_type 'creatorType'
end

# Use in document model
class Document < Lutaml::Model::Serializable
  namespace DocumentNamespace
  
  attribute :title, DcTitleType
  attribute :creator, DcCreatorType
  attribute :content, :string

  xml do
    root 'document'
    
    map_element 'title', to: :title      # Uses DublinCoreNamespace
    map_element 'creator', to: :creator  # Uses DublinCoreNamespace
    map_element 'content', to: :content  # No type namespace
  end
end

doc = Document.new(
  title: 'Example Document',
  creator: 'John Doe',
  content: 'Document content'
)

puts doc.to_xml
# => <doc:document
#      xmlns:doc="https://example.com/document"
#      xmlns:dc="http://purl.org/dc/elements/1.1/">
#      <dc:title>Example Document</dc:title>
#      <dc:creator>John Doe</dc:creator>
#      <content>Document content</content>
#    </doc:document>

# Round-trip works correctly
parsed = Document.from_xml(doc.to_xml)
parsed == doc  # => true
----
====

=== Multi-namespace document with consolidated declarations

.Using namespace_scope for cleaner multi-namespace XML
[example]
====
[source,ruby]
----
# Define namespaces
class VcardNamespace < Lutaml::Model::XmlNamespace
  uri "urn:ietf:params:xml:ns:vcard-4.0"
  prefix_default "vcard"
end

class DcNamespace < Lutaml::Model::XmlNamespace
  uri "http://purl.org/dc/elements/1.1/"
  prefix_default "dc"
end

class DctermsNamespace < Lutaml::Model::XmlNamespace
  uri "http://purl.org/dc/terms/"
  prefix_default "dcterms"
end

# Define types with namespaces
class DcTitleType < Lutaml::Model::Type::String
  xml_namespace DcNamespace
end

class DctermsCreatedType < Lutaml::Model::Type::DateTime
  namespace DctermsNamespace
end

class VcardVersion < Lutaml::Model::Type::String
  namespace VcardNamespace
end

# Use namespace_scope to consolidate declarations
class Vcard < Lutaml::Model::Serializable
  namespace VcardNamespace

  attribute :version, VcardVersion
  attribute :title, DcTitleType
  attribute :full_name, :string
  attribute :created, DctermsCreatedType

  xml do
    root "vCard"
    namespace_scope [VcardNamespace, DcNamespace, DctermsNamespace]  <1>

    map_element "version", to: :version
    map_element "title", to: :title
    map_element "fn", to: :full_name
    map_element "created", to: :created
  end
end

vcard = Vcard.new(
  version: "4.0",
  title: "Contact: Dr. John Doe",
  full_name: "Dr. John Doe",
  created: DateTime.parse("2024-06-01T12:00:00Z")
)

puts vcard.to_xml
# => <vcard:vCard xmlns:vcard="urn:ietf:params:xml:ns:vcard-4.0"
#                 xmlns:dc="http://purl.org/dc/elements/1.1/"
#                 xmlns:dcterms="http://purl.org/dc/terms/">
#      <vcard:version>4.0</vcard:version>
#      <dc:title>Contact: Dr. John Doe</dc:title>
#      <vcard:fn>Dr. John Doe</vcard:fn>
#      <dcterms:created>2024-06-01T12:00:00+00:00</dcterms:created>
#    </vcard:vCard>

# Round-trip deserialization works
parsed = Vcard.from_xml(vcard.to_xml)
parsed == vcard  # => true
----
<1> All three namespaces declared at root for cleaner output
====

== schemaLocation pattern

=== Automatic xsi:schemaLocation

.Using schema_location metadata attribute
[example]
====
[source,ruby]
----
class Ceramic < Lutaml::Model::Serializable
  attribute :type, :string
  attribute :glaze, :string
  attribute :color, :string

  xml do
    root 'Ceramic'
    namespace 'http://example.com/ceramic', 'cera'
    map_element 'Type', to: :type, namespace: :inherit
    map_element 'Glaze', to: :glaze
    map_attribute 'color', to: :color,
      namespace: 'http://example.com/color', prefix: 'clr'
  end
end

xml_content = <<~XML
<cera:Ceramic
  xmlns:cera="http://example.com/ceramic"
  xmlns:clr="http://example.com/color"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  clr:color="navy-blue"
  xsi:schemaLocation="
    http://example.com/ceramic http://example.com/ceramic.xsd
    http://example.com/color http://example.com/color.xsd
  ">
  <cera:Type>Porcelain</cera:Type>
  <Glaze>Clear</Glaze>
</cera:Ceramic>
XML

c = Ceramic.from_xml(xml_content)
schema_loc = c.schema_location  # Automatically captured

# Round-trip with schema location preserved
new_c = Ceramic.new(
  type: "Porcelain",
  glaze: "Clear",
  color: "navy-blue",
  schema_location: schema_loc
)
puts new_c.to_xml
# xsi:schemaLocation automatically included
----
====

== Advanced namespace patterns

=== Nested namespaced elements with inheritance

When working with deeply nested XML structures, LutaML::Model provides
sophisticated namespace inheritance optimization. Elements that share the same
namespace as their parent will inherit the namespace declaration, avoiding
redundant `xmlns` attributes.

==== Same namespace inheritance (UnitsML scenario)

When all nested models share the same namespace, the framework automatically
inherits the namespace from the root element, producing clean XML without
redundant namespace declarations.

.Models with shared namespace
[example]
====
[source,ruby]
----
class UnitSystem < Lutaml::Model::Serializable
  attribute :name, :string
  attribute :type, :string

  xml do
    root "UnitSystem"
    namespace "https://schema.example.org/units/1.0"
    map_attribute "name", to: :name
    map_attribute "type", to: :type
  end
end

class UnitName < Lutaml::Model::Serializable
  attribute :value, :string

  xml do
    root "UnitName"
    namespace "https://schema.example.org/units/1.0"
    map_content to: :value
  end
end

class EnumeratedRootUnit < Lutaml::Model::Serializable
  attribute :unit, :string
  attribute :prefix, :string

  xml do
    root "EnumeratedRootUnit"
    namespace "https://schema.example.org/units/1.0"
    map_attribute "unit", to: :unit
    map_attribute "prefix", to: :prefix
  end
end

class RootUnits < Lutaml::Model::Serializable
  attribute :enumerated_root_units, EnumeratedRootUnit, collection: true

  xml do
    root "RootUnits"
    namespace "https://schema.example.org/units/1.0"
    map_element "EnumeratedRootUnit", to: :enumerated_root_units
  end
end

class Unit < Lutaml::Model::Serializable
  attribute :id, :string
  attribute :unit_system, UnitSystem
  attribute :unit_name, UnitName
  attribute :root_units, RootUnits

  xml do
    root "Unit"
    namespace "https://schema.example.org/units/1.0"
    map_attribute "id", to: :id
    map_element "UnitSystem", to: :unit_system
    map_element "UnitName", to: :unit_name
    map_element "RootUnits", to: :root_units
  end
end
----

[source,ruby]
----
# Create nested structure
unit_system = UnitSystem.new(name: "SI", type: "SI_derived")
unit_name = UnitName.new(value: "meter")
meter_unit = EnumeratedRootUnit.new(unit: "meter")
gram_unit = EnumeratedRootUnit.new(unit: "gram", prefix: "k")
root_units = RootUnits.new(enumerated_root_units: [meter_unit, gram_unit])

unit = Unit.new(
  id: "U_m",
  unit_system: unit_system,
  unit_name: unit_name,
  root_units: root_units
)
----

Generated XML shows namespace declared only once on the root element:

[source,xml]
----
<Unit xmlns="https://schema.example.org/units/1.0" id="U_m">
  <UnitSystem name="SI" type="SI_derived"/>
  <UnitName>meter</UnitName>
  <RootUnits>
    <EnumeratedRootUnit unit="meter"/>
    <EnumeratedRootUnit unit="gram" prefix="k"/>
  </RootUnits>
</Unit>
----

*Key behaviors:*

* The `xmlns` declaration appears only on the root `Unit` element
* All child elements (`UnitSystem`, `UnitName`, `RootUnits`, `EnumeratedRootUnit`) inherit the namespace
* No redundant namespace declarations on child elements
* Clean, optimized XML output following namespace inheritance best practices
====

==== Mixed namespace handling

When different namespaces are used within the same document structure,
LutaML::Model correctly manages namespace declarations, adding `xmlns` attributes
only when the namespace changes from the parent element.

.Models with mixed namespaces
[example]
====
[source,ruby]
----
class MathContent < Lutaml::Model::Serializable
  attribute :value, :string

  xml do
    root "math"
    namespace "http://www.w3.org/1998/Math/MathML"
    map_content to: :value
  end
end

class UnitSymbol < Lutaml::Model::Serializable
  attribute :type, :string
  attribute :math, MathContent

  xml do
    root "UnitSymbol"
    namespace "https://schema.example.org/units/1.0"
    map_attribute "type", to: :type
    map_element "math", to: :math
  end
end

class UnitWithMath < Lutaml::Model::Serializable
  attribute :id, :string
  attribute :unit_symbol, UnitSymbol

  xml do
    root "Unit"
    namespace "https://schema.example.org/units/1.0"
    map_attribute "id", to: :id
    map_element "UnitSymbol", to: :unit_symbol
  end
end
----

[source,ruby]
----
# Create structure with mixed namespaces
math = MathContent.new(value: "x+y")
unit_symbol = UnitSymbol.new(type: "MathML", math: math)
unit_with_math = UnitWithMath.new(id: "U_m.kg-2", unit_symbol: unit_symbol)
----

Generated XML correctly handles namespace transitions:

[source,xml]
----
<Unit xmlns="https://schema.example.org/units/1.0" id="U_m.kg-2">
  <UnitSymbol type="MathML">
    <math xmlns="http://www.w3.org/1998/Math/MathML">x+y</math>
  </UnitSymbol>
</Unit>
----

*Key behaviors:*

* The `Unit` element declares the units namespace (`https://schema.example.org/units/1.0`)
* `UnitSymbol` inherits the same namespace from `Unit` (no xmlns needed)
* `math` element declares its own namespace (`http://www.w3.org/1998/Math/MathML`) because it differs from the parent
* Namespace declarations are added only where the namespace changes
* Efficient XML with minimal namespace declarations
====

==== Mixed nested namespace with multiple levels

For more complex scenarios involving multiple nesting levels with different 
namespaces at various depths, the framework handles each namespace transition 
appropriately.

.Complex mixed namespace structure
[example]
====
[source,ruby]
----
# Define additional namespaces for deeper nesting
class MetadataNamespace < Lutaml::Model::XmlNamespace
  uri "https://schema.example.org/metadata/1.0"
  prefix_default "meta"
end

class AnnotationNamespace < Lutaml::Model::XmlNamespace  
  uri "https://schema.example.org/annotation/1.0"
  prefix_default "ann"
end

# Nested models with different namespaces at each level
class Annotation < Lutaml::Model::Serializable
  attribute :text, :string
  attribute :author, :string

  xml do
    root "annotation"
    namespace "https://schema.example.org/annotation/1.0"
    map_element "text", to: :text
    map_attribute "author", to: :author
  end
end

class Metadata < Lutaml::Model::Serializable
  attribute :version, :string
  attribute :annotation, Annotation

  xml do
    root "metadata"
    namespace "https://schema.example.org/metadata/1.0"
    map_attribute "version", to: :version
    map_element "annotation", to: :annotation
  end
end

class ExtendedUnitSymbol < Lutaml::Model::Serializable
  attribute :type, :string
  attribute :math, MathContent      # MathML namespace
  attribute :metadata, Metadata    # Metadata namespace -> Annotation namespace

  xml do
    root "UnitSymbol"
    namespace "https://schema.example.org/units/1.0"
    map_attribute "type", to: :type
    map_element "math", to: :math
    map_element "metadata", to: :metadata
  end
end

class ExtendedUnitWithMath < Lutaml::Model::Serializable
  attribute :id, :string
  attribute :unit_symbol, ExtendedUnitSymbol

  xml do
    root "Unit"
    namespace "https://schema.example.org/units/1.0"
    map_attribute "id", to: :id
    map_element "UnitSymbol", to: :unit_symbol
  end
end
----

[source,ruby]
----
# Create deeply nested structure with mixed namespaces
annotation = Annotation.new(text: "Special mathematical notation", author: "Dr. Smith")
metadata = Metadata.new(version: "2.0", annotation: annotation)
math = MathContent.new(value: "∫f(x)dx")
extended_symbol = ExtendedUnitSymbol.new(
  type: "Complex",
  math: math,
  metadata: metadata
)
extended_unit = ExtendedUnitWithMath.new(
  id: "U_complex",
  unit_symbol: extended_symbol
)
----

Generated XML with multiple namespace levels:

[source,xml]
----
<Unit xmlns="https://schema.example.org/units/1.0" id="U_complex">
  <UnitSymbol type="Complex">
    <math xmlns="http://www.w3.org/1998/Math/MathML">∫f(x)dx</math>
    <metadata xmlns="https://schema.example.org/metadata/1.0" version="2.0">
      <annotation xmlns="https://schema.example.org/annotation/1.0" author="Dr. Smith">
        <text>Special mathematical notation</text>
      </annotation>
    </metadata>
  </UnitSymbol>
</Unit>
----

*Key behaviors for complex nesting:*

* **Level 1** (`Unit`): Units namespace declared
* **Level 2** (`UnitSymbol`): Inherits units namespace (no xmlns)
* **Level 3a** (`math`): Declares MathML namespace (different from parent)
* **Level 3b** (`metadata`): Declares metadata namespace (different from parent)
* **Level 4** (`annotation`): Declares annotation namespace (different from metadata parent)
* **Level 5** (`text`): Inherits annotation namespace (same as parent)

This demonstrates how the framework:

1. Tracks namespace context at each nesting level
2. Only declares xmlns when namespace actually changes
3. Maintains proper inheritance even across multiple namespace transitions
4. Produces clean, standards-compliant XML regardless of nesting complexity
====

=== Complex nested namespace scenarios

==== Multiple nesting levels with same namespace

For deeply nested structures where all elements share the same namespace,
the framework optimizes by declaring the namespace only at the root level.

[source,ruby]
----
# Given the UnitsML example above with 4 nesting levels:
# Unit -> UnitSystem/UnitName/RootUnits -> EnumeratedRootUnit (collection)

unit = Unit.from_xml(xml_with_multiple_nesting)
# All nested elements correctly inherit the namespace
# No redundant xmlns declarations at any level
----

==== Mixed namespaces at different nesting levels

When namespaces change at various nesting levels, each namespace transition
is handled correctly with appropriate `xmlns` declarations.

[source,ruby]
----
# Pattern: 
# - Level 1: Units namespace
# - Level 2: Units namespace (inherited)
# - Level 3: MathML namespace (new declaration needed)

# The framework automatically:
# 1. Inherits namespace when same as parent
# 2. Declares namespace when different from parent
# 3. Optimizes declarations for minimal XML output
----

*Namespace inheritance rules:*

1. **Same namespace as parent**: Child element inherits parent's namespace (no xmlns)
2. **Different namespace from parent**: Child element declares its own namespace (xmlns added)
3. **Root element**: Always declares its own namespace if specified
4. **Collections**: Each item in collection follows same inheritance rules
5. **Round-trip preservation**: Namespace structure preserved during serialization/deserialization

This approach ensures both XML correctness and optimal output size, following
W3C XML Namespace recommendations for namespace inheritance and declaration.