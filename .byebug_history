n
c
type
name
c!
h
self
h
c
n
collection_name
n
value.map { |v| type.cast(v) }
value
n
c
exit
value.map { |v| type.cast(v) }
value
valu
n
type
n
c
exit
collection_name
items
n
name
self
name
value
n
self
c
super()
n
collection_name
c
attr.collection_class.new([], attr.name, attr.type)
c
self
c
exit
self.class.attributes
c
exit
self.class < Lutaml::Model::Collection
self.class
self
c
self.class
c
collection_name
n
self.class
self
n
value
n
default
n
self
name
value
name
c
self.class
c
exit
n
value
attr
n
c
exit
n
name
c
self.class
c
exit
attr.collection_class.new([], attr.name, attr.type)
attr.collection_class.new
n
attr.collection?
c
exit
attr.type
attr
attr.collection?
attrs
attr.default
attr
name
c
options
type
name
c
exit
options[:default].call
options[:default]
options
@options[:default] = -> { collection_class.new([], name, type) } unless options[:default]
n
collection_class.new([], name, type)
c
exit
options
c
options
c
options
exit
self
options
attr.default
attr
n
type
name
c
name
c
type
name
exit
self.class.attributes.values.first.default
self.class.attributes.values.first
self.class.attributes
self.class
exit
value
vlaue
c
value
c
name
value
c
value
c
self.class.attributes
self.class
c
type
c
value
c
value
n
 self.class.def_delegators :"@#{@collection_name}", :each, :<<, :push, :size
@collection_name
self.class
n
self.class
n
self.class.attributes
n
type
collection_name
n
step
st
s
self.class.attributes
c
exit
collection_name
self.class < Lutaml::Model::Collection
self < Lutaml::Model::Collection
c
collection_class.new([], name, type).abc
collection_class.new([], name, type)
c
type
name
exit
attr.default
attr.default.call
value
attr
c
exit
c
value
c
exit
c
exit
n
c
collection_name
c
exit
n
attrs
c
exit
where
c
where
c
type
c
collection_name
c
collection_name
c
collection_name
c
exit
self.class.def_delegators :"@#{@collection_name}", :each, :<<, :push, :size, :to_s, :to_yaml, :to_json, :empty?, :[], :length, :+, :compact, :first, :last, :join, :to_a, :to_ary, :eql?
def_delegators :"@#{@collection_name}", :each, :<<, :push, :size, :to_s, :to_yaml, :to_json, :empty?, :[], :length, :+, :compact, :first, :last, :join, :to_a, :to_ary, :eql?
:"@#{@collection_name}"
self.abc
self
send(:collection_var_name)
n
c
exit
collection_var_name
:"@#{collection_name}"
"@#{collection_name}"
:"@#{collection_name}"
@collection_name
send(:collection_var_name)
send
self.class.def_delegators
self.class
def_delegators
n
c
where
exit
send(:collection_var_name)
c
n
collection_name
c
type
name
c
type
c
value
c
type
c
n
value.is_a?(Lutaml::Model::Collection)
value.is_a?(Array)
value
c
collection_name
